<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Game Map</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #d4af37;
            --secondary: #8b7355;
            --dark: #1a1410;
            --darker: #0d0a08;
            --light: #f5e6d3;
            --accent: #c9a961;
            --danger: #c53030;
            --success: #38a169;
            --shadow: rgba(0, 0, 0, 0.6);
        }

        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #1a1410 0%, #2d2416 100%);
            color: var(--light);
            overflow: hidden;
            height: 100vh;
        }

        /* Login Modal uses existing modal styles */
        .login-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .login-input {
            padding: 0.75rem 1rem;
            background: rgba(42, 35, 26, 0.6);
            border: 1px solid var(--secondary);
            border-radius: 6px;
            color: var(--light);
            font-size: 1rem;
            font-family: 'Lato', sans-serif;
        }

        .login-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(42, 35, 26, 0.8);
        }

        .login-btn {
            padding: 0.875rem 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: var(--darker);
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
            font-family: 'Lato', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(212, 175, 55, 0.4);
        }

        .login-error {
            color: var(--danger);
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-left: auto;
            color: var(--light);
            font-size: 0.9rem;
        }

        .admin-badge {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: var(--darker);
            padding: 0.35rem 0.75rem;
            border-radius: 15px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .viewer-badge {
            background: rgba(139, 115, 85, 0.3);
            color: var(--light);
            padding: 0.35rem 0.75rem;
            border-radius: 15px;
            font-weight: 600;
            font-size: 0.85rem;
            border: 1px solid var(--secondary);
        }

        .logout-btn {
            background: rgba(139, 115, 85, 0.3);
            color: var(--light);
            border: 1px solid var(--secondary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-family: 'Lato', sans-serif;
        }

        .logout-btn:hover {
            background: rgba(139, 115, 85, 0.5);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            display: none;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--secondary);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(to bottom, var(--darker), var(--dark));
            border-bottom: 2px solid var(--primary);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 1000;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 2px 2px 4px var(--shadow);
            letter-spacing: 2px;
        }

        .search-container {
            flex: 1;
            max-width: 500px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1.25rem;
            background: rgba(42, 35, 26, 0.8);
            border: 1px solid var(--secondary);
            border-radius: 8px;
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
            font-family: 'Lato', sans-serif;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
            background: rgba(42, 35, 26, 0.95);
        }

        .search-input::placeholder {
            color: rgba(245, 230, 211, 0.5);
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            background: var(--dark);
            border: 1px solid var(--secondary);
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 8px 24px var(--shadow);
            z-index: 1000;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .result-name {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }

        .result-meta {
            font-size: 0.85rem;
            color: rgba(245, 230, 211, 0.7);
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Lato', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: var(--darker);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(212, 175, 55, 0.4);
        }

        .btn-secondary {
            background: rgba(139, 115, 85, 0.3);
            color: var(--light);
            border: 1px solid var(--secondary);
        }

        .btn-secondary:hover {
            background: rgba(139, 115, 85, 0.5);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: linear-gradient(to bottom, var(--dark), var(--darker));
            border-right: 2px solid var(--secondary);
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 4px 0 20px var(--shadow);
        }

        .sidebar h3 {
            font-family: 'Cinzel', serif;
            color: var(--primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        .map-list {
            list-style: none;
        }

        .map-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(42, 35, 26, 0.5);
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .map-item.draggable {
            cursor: move;
        }

        .map-item.dragging {
            opacity: 0.5;
            background: rgba(212, 175, 55, 0.3);
        }

        .map-item.drag-over {
            border-top: 3px solid var(--primary);
            margin-top: 0.5rem;
        }

        .map-item.drag-over-bottom {
            border-bottom: 3px solid var(--primary);
            margin-bottom: 0.5rem;
        }

        .map-drag-handle {
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary);
            font-size: 1rem;
            cursor: move;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .map-item:hover .map-drag-handle {
            opacity: 1;
        }

        .map-item-name {
            margin-left: 1.5rem;
        }

        .map-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--primary);
        }

        .map-item.active {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(201, 169, 97, 0.2));
            border-color: var(--primary);
        }

        .map-item.submap {
            margin-left: 1.5rem;
            font-size: 0.9rem;
        }

        .map-item-name {
            font-weight: 600;
            color: var(--light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-item-actions {
            display: none;
            gap: 0.5rem;
        }

        .map-item:hover .map-item-actions {
            display: flex;
        }

        .map-action-btn {
            background: none;
            border: none;
            color: var(--primary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .map-action-btn:hover {
            color: var(--accent);
            transform: scale(1.2);
        }

        .map-item-count {
            font-size: 0.85rem;
            color: rgba(245, 230, 211, 0.6);
            margin-top: 0.25rem;
        }

        /* Map Canvas */
        .map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #2a231a 0%, #1a1410 100%);
        }

        .map-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
        }

        .map-canvas.grabbing {
            cursor: grabbing;
        }

        .map-canvas.adding-node {
            cursor: crosshair;
        }

        .map-image-container {
            position: relative;
            transform-origin: 0 0;
            left: 0;
            top: 0;
        }

        .map-image {
            max-width: none;
            user-select: none;
            pointer-events: none;
        }

        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            pointer-events: auto;
            margin-left: 0;
            margin-top: 0;
        }

        .node-icon {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 12px var(--shadow), 0 0 0 3px rgba(212, 175, 55, 0.5);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .node:hover .node-icon {
            transform: scale(1.3);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.8), 0 0 0 4px var(--primary);
        }

        .node.highlighted {
            animation: pulse 1.5s ease-in-out infinite;
            z-index: 200;
        }

        @keyframes pulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.4);
            }
        }

        .node-combat { background: linear-gradient(135deg, #c53030, #9b2c2c); }
        .node-event { background: linear-gradient(135deg, #805ad5, #6b46c1); }
        .node-card { background: linear-gradient(135deg, #38a169, #2f855a); }
        .node-crafter { background: linear-gradient(135deg, #dd6b20, #c05621); }
        .node-rest { background: linear-gradient(135deg, #3182ce, #2c5282); }
        .node-character { background: linear-gradient(135deg, #d69e2e, #b7791f); }
        .node-transition { background: linear-gradient(135deg, #718096, #4a5568); }
        .node-shop { background: linear-gradient(135deg, #38b2ac, #319795); }
        .node-quest { background: linear-gradient(135deg, #ed8936, #dd6b20); }
        .node-rift { background: linear-gradient(135deg, #9f7aea, #805ad5); }
        .node-boss { background: linear-gradient(135deg, #e53e3e, #c53030); }
        .node-information { background: linear-gradient(135deg, #4299e1, #3182ce); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(to bottom, var(--dark), var(--darker));
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px var(--shadow);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--primary);
            font-weight: 700;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(197, 48, 48, 0.2);
            color: var(--danger);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--light);
            font-size: 0.95rem;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 0.75rem;
            background: rgba(42, 35, 26, 0.6);
            border: 1px solid var(--secondary);
            border-radius: 6px;
            color: var(--light);
            font-size: 1rem;
            font-family: 'Lato', sans-serif;
            transition: all 0.3s ease;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(42, 35, 26, 0.8);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .tags-input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(42, 35, 26, 0.6);
            border: 1px solid var(--secondary);
            border-radius: 6px;
            min-height: 50px;
        }

        .tag {
            background: linear-gradient(135deg, var(--secondary), var(--accent));
            color: var(--light);
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: grab;
            transition: all 0.2s;
            user-select: none;
        }
        
        .tag:active {
            cursor: grabbing;
        }
        
        .tag-drag-handle {
            cursor: grab;
            font-size: 0.7rem;
            line-height: 1;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .tag-remove:hover {
            opacity: 1;
        }

        .tag-input {
            flex: 1;
            min-width: 120px;
            border: none;
            background: transparent;
            color: var(--light);
            outline: none;
            padding: 0.35rem;
        }

        .options-container {
            border: 1px solid var(--secondary);
            border-radius: 6px;
            padding: 1rem;
            background: rgba(42, 35, 26, 0.3);
        }

        .option-item {
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(42, 35, 26, 0.5);
            border-radius: 6px;
            position: relative;
        }

        .option-item:last-child {
            margin-bottom: 0;
        }

        .option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .option-number {
            font-weight: 700;
            color: var(--primary);
        }

        .option-remove {
            background: var(--danger);
            color: white;
            border: none;
            padding: 0.35rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .option-remove:hover {
            background: #9b2c2c;
        }

        /* Variants */
        .variants-container {
            border: 1px solid var(--secondary);
            border-radius: 6px;
            padding: 1rem;
            background: rgba(42, 35, 26, 0.3);
        }

        .variant-item {
            display: none;
            padding: 1rem;
            background: rgba(42, 35, 26, 0.5);
            border-radius: 6px;
            border: 1px solid var(--secondary);
        }

        .variant-item.active {
            display: block;
        }

        .variant-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .variant-name-input {
            font-weight: 600;
        }

        .variant-chance-input {
            text-align: center;
        }

        .variant-tabs {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .variant-tab {
            padding: 0.5rem 1rem;
            background: rgba(139, 115, 85, 0.3);
            border: 1px solid var(--secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .variant-tab:hover {
            background: rgba(139, 115, 85, 0.5);
        }

        .variant-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: var(--darker);
            border-color: var(--primary);
            font-weight: 600;
        }

        .variant-tab-chance {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        /* Follow-up Events */
        .followup-events-container {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(42, 35, 26, 0.3);
            border: 1px solid var(--secondary);
            border-radius: 6px;
        }

        .followup-event-item {
            background: rgba(42, 35, 26, 0.5);
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            border: 1px solid var(--secondary);
        }

        .followup-event-item:last-child {
            margin-bottom: 0;
        }

        .followup-event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .followup-event-label {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.95rem;
        }

        .followup-event-remove {
            background: var(--danger);
            color: white;
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .followup-event-remove:hover {
            background: #9b2c2c;
        }

        .followup-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0.5rem 0;
            color: var(--primary);
            font-size: 1.2rem;
        }

        .rewards-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            justify-content: flex-end;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #9b2c2c;
        }

        .zoom-controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .zoom-btn {
            width: 48px;
            height: 48px;
            background: rgba(26, 20, 16, 0.9);
            border: 2px solid var(--primary);
            border-radius: 8px;
            color: var(--primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .zoom-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .mode-indicator {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: var(--darker);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
            z-index: 100;
            display: none;
            animation: fadeInDown 0.3s ease;
        }

        .mode-indicator.active {
            display: block;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translate(-50%, -10px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .context-menu {
            position: fixed;
            background: var(--dark);
            border: 2px solid var(--primary);
            border-radius: 8px;
            box-shadow: 0 8px 24px var(--shadow);
            z-index: 3000;
            min-width: 150px;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .context-menu-item.danger:hover {
            background: rgba(197, 48, 48, 0.2);
            color: var(--danger);
        }

        .no-results {
            padding: 2rem;
            text-align: center;
            color: rgba(245, 230, 211, 0.6);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(26, 20, 16, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Node Viewer Panel */
        .node-viewer {
            position: absolute;
            right: 2rem;
            top: 2rem;
            width: 350px;
            max-height: calc(100vh - 8rem);
            background: linear-gradient(to bottom, var(--dark), var(--darker));
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow);
            z-index: 500;
            display: none;
            overflow-y: auto;
            animation: slideInRight 0.3s ease;
        }

        .node-viewer.active {
            display: block;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .node-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--secondary);
        }

        .node-viewer-title {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            color: var(--primary);
            font-weight: 700;
            flex: 1;
            word-break: break-word;
        }

        .node-viewer-close {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .node-viewer-close:hover {
            background: rgba(197, 48, 48, 0.2);
            color: var(--danger);
        }

        .node-viewer-type {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .node-viewer-section {
            margin-bottom: 1.5rem;
        }

        .node-viewer-section:last-child {
            margin-bottom: 0;
        }

        .node-viewer-label {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .node-viewer-content {
            color: var(--light);
            line-height: 1.6;
        }

        .node-viewer-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .node-viewer-tag {
            background: rgba(139, 115, 85, 0.3);
            color: var(--light);
            padding: 0.35rem 0.75rem;
            border-radius: 15px;
            font-size: 0.85rem;
            border: 1px solid var(--secondary);
        }

        .node-viewer-option {
            background: rgba(42, 35, 26, 0.5);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            border: 1px solid var(--secondary);
        }

        .node-viewer-option:last-child {
            margin-bottom: 0;
        }

        .node-viewer-option-label {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .node-viewer-option-desc {
            color: rgba(245, 230, 211, 0.8);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .node-viewer-rewards {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: rgba(245, 230, 211, 0.7);
        }

        .node-viewer-reward {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .node-viewer-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--secondary);
        }

        .btn-small {
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Login Modal (triggered by button) -->
    <div class="modal" id="loginModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title">Admin Login</h2>
                <button class="close-btn" id="closeLoginModalBtn">Ã—</button>
            </div>
            <form class="login-form" id="loginForm">
                <input type="email" class="login-input" id="loginEmail" placeholder="Admin Email" required>
                <input type="password" class="login-input" id="loginPassword" placeholder="Password" required>
                <button type="submit" class="login-btn">Login</button>
                <div class="login-error" id="loginError"></div>
            </form>
        </div>
    </div>

    <div class="app-container" id="appContainer">
        <!-- Header -->
        <div class="header">
            <div class="title">âš” MAP FORGE v2.0 âš”</div>
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Search nodes, tags, or content...">
                <div class="search-results" id="searchResults"></div>
            </div>
            <div class="header-actions">
                <button class="btn btn-secondary" id="addMapBtn">+ New Map</button>
                <button class="btn btn-primary" id="addNodeBtn">+ Add Node</button>
            </div>
            <div class="user-info">
                <span id="userRole"></span>
                <button class="btn btn-primary" id="loginBtn" style="display: none;">ðŸ” Admin Login</button>
                <button class="logout-btn" id="logoutBtn" style="display: none;">Logout</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar">
                <h3>Maps</h3>
                <ul class="map-list" id="mapList"></ul>
            </div>

            <!-- Map Canvas -->
            <div class="map-container">
                <div class="mode-indicator" id="modeIndicator">Click on the map to place node</div>
                <div class="map-canvas" id="mapCanvas">
                    <div class="map-image-container" id="mapImageContainer"></div>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInBtn">+</button>
                    <button class="zoom-btn" id="zoomResetBtn">âŠ™</button>
                    <button class="zoom-btn" id="zoomOutBtn">âˆ’</button>
                </div>

                <!-- Node Viewer Panel -->
                <div class="node-viewer" id="nodeViewer">
                    <div class="node-viewer-header">
                        <h3 class="node-viewer-title" id="viewerNodeName"></h3>
                        <button class="node-viewer-close" id="closeViewerBtn">Ã—</button>
                    </div>
                    <div id="viewerContent"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Node Modal -->
    <div class="modal" id="nodeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Create New Node</h2>
                <button class="close-btn" id="closeModalBtn">Ã—</button>
            </div>
            <form id="nodeForm">
                <div class="form-group">
                    <label class="form-label">Name</label>
                    <input type="text" class="form-input" id="nodeName" placeholder="Enter node name" required>
                </div>

                <div class="form-group">
                    <label class="form-label">
                        Node Variants (for RNG/chance-based encounters)
                        <small style="display: block; font-weight: normal; color: rgba(245, 230, 211, 0.6); margin-top: 0.25rem;">
                            Add multiple versions when the same location has different possible encounters
                        </small>
                    </label>
                    <div class="variants-container" id="variantsContainer">
                        <div class="variant-item active" data-variant-index="0">
                            <div class="variant-header">
                                <input type="text" class="form-input variant-name-input" placeholder="Variant name (e.g., 'e_sen4_a1' or 'Encounter A')" value="Default" style="flex: 1;">
                                <input type="number" class="form-input variant-chance-input" placeholder="%" min="0" max="100" value="100" style="width: 80px; margin-left: 0.5rem;">
                                <span style="margin-left: 0.5rem; color: var(--light);">%</span>
                                <button type="button" class="btn btn-secondary btn-small" onclick="removeVariant(this)" style="margin-left: 0.5rem; display: none;">Remove</button>
                            </div>
                            <div class="variant-content" style="margin-top: 1rem;">
                                <!-- Variant-specific content will be inserted here by JS -->
                            </div>
                        </div>
                    </div>
                    <button type="button" class="btn btn-secondary" id="addVariantBtn" style="margin-top: 1rem; width: 100%;">+ Add Variant</button>
                    <div class="variant-tabs" id="variantTabs" style="display: flex; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                        <!-- Variant tabs will be added here by JS -->
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Node Type</label>
                    <select class="form-select" id="nodeType" required>
                        <option value="combat">Combat</option>
                        <option value="event">Event (rarity)</option>
                        <option value="card">Card node</option>
                        <option value="crafter">Crafter node</option>
                        <option value="rest">Rest node</option>
                        <option value="character">Character</option>
                        <option value="transition">Map transition</option>
                        <option value="shop">Shop</option>
                        <option value="quest">Quest end</option>
                        <option value="rift">Eldritch Rift</option>
                        <option value="boss">Region boss</option>
                        <option value="information">Information</option>
                    </select>
                </div>

                <div class="form-group" id="mapLinkGroup" style="display: none;">
                    <label class="form-label">Linked Map (for transitions)</label>
                    <select class="form-select" id="nodeMapLink">
                        <option value="">None</option>
                    </select>
                    <small style="color: rgba(245, 230, 211, 0.6); display: block; margin-top: 0.5rem;">Select which map this node transitions to</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="nodeDescription" placeholder="Enter description"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tags-input-container" id="tagsContainer">
                        <input type="text" class="tag-input" id="tagInput" placeholder="Add a tag...">
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Options (Actions at this node)</label>
                    <div class="options-container" id="optionsContainer">
                        <div class="option-item">
                            <div class="option-header">
                                <span class="option-number">Option 1</span>
                                <button type="button" class="option-remove" onclick="removeOption(this)">Remove</button>
                            </div>
                            <input type="text" class="form-input" placeholder="Option label (e.g., 'Talk', 'Buy', 'Fight')" data-option="label">
                            <input type="text" class="form-input" placeholder="Option description (optional)" data-option="description" style="margin-top: 0.5rem;">
                            <div class="rewards-row">
                                <input type="number" class="form-input" placeholder="Gold" data-option="gold">
                                <input type="number" class="form-input" placeholder="Shards" data-option="shards">
                                <input type="number" class="form-input" placeholder="EXP" data-option="exp">
                            </div>
                        </div>
                    </div>
                    <button type="button" class="btn btn-secondary" style="margin-top: 1rem; width: 100%;" onclick="addOption()">+ Add Option</button>
                </div>

                <div class="form-actions">
                    <button type="button" class="btn btn-danger" id="deleteNodeBtn" style="display: none;">Delete Node</button>
                    <button type="button" class="btn btn-secondary" id="cancelBtn">Cancel</button>
                    <button type="submit" class="btn btn-primary" id="saveNodeBtn">Save Node</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Map Modal -->
    <div class="modal" id="mapModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create New Map</h2>
                <button class="close-btn" id="closeMapModalBtn">Ã—</button>
            </div>
            <form id="mapForm">
                <div class="form-group">
                    <label class="form-label">Map Name</label>
                    <input type="text" class="form-input" id="mapName" placeholder="Enter map name" required>
                </div>

                <div class="form-group">
                    <label class="form-label">Parent Map (optional)</label>
                    <select class="form-select" id="parentMap">
                        <option value="">None (Root Map)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Map Image</label>
                    <input type="file" class="form-input" id="mapImageFile" accept="image/*" style="padding: 0.5rem;">
                    <input type="text" class="form-input" id="mapImageUrl" placeholder="Or enter image URL" style="margin-top: 0.5rem;">
                    <div id="imagePreviewContainer" style="margin-top: 1rem; display: none;">
                        <div style="font-size: 0.9rem; color: var(--primary); margin-bottom: 0.5rem;">Preview:</div>
                        <img id="imagePreview" style="max-width: 100%; max-height: 200px; border-radius: 6px; border: 1px solid var(--secondary);">
                        <div id="imageStats" style="margin-top: 0.5rem; font-size: 0.85rem; color: rgba(245, 230, 211, 0.7);"></div>
                    </div>
                    <small style="color: rgba(245, 230, 211, 0.6); display: block; margin-top: 0.5rem;">
                        âœ¨ Images are automatically compressed to 85% quality and max 3000x3000px
                    </small>
                </div>

                <div class="form-actions">
                    <button type="button" class="btn btn-danger" id="deleteMapBtn" style="display: none;">Delete Map</button>
                    <button type="button" class="btn btn-secondary" id="cancelMapBtn">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save Map</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" id="contextEdit">ðŸ‘ï¸ View Node</div>
        <div class="context-menu-item" id="contextMove">â†”ï¸ Move Node</div>
        <div class="context-menu-item danger" id="contextDelete">ðŸ—‘ï¸ Delete Node</div>
    </div>

    <!-- Hidden file input for import -->

    <script>
        // ==========================================
        // SUPABASE CONFIGURATION
        // IMPORTANT: Replace these with your actual Supabase values!
        // Get these from: Supabase Dashboard â†’ Settings â†’ API
        // ==========================================
        const SUPABASE_URL = 'https://sczwwgszicbwomriucuz.supabase.co'; // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_ANON_KEY = 'sb_publishable_7Zh2AuEoohMwZKFLdTZjHQ_9fmeso6p'; // Publishable key

        // Initialize Supabase client
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Authentication state
        let isAdmin = false;
        let currentUser = null;

        // Variant management
        let currentVariantIndex = 0;
        let currentNodeVariants = [];

        // Data Storage
        let maps = [];
        let currentMapId = null;
        let editingNodeId = null;
        let viewingNodeId = null;
        let isAddingNode = false;
        let pendingNodePosition = null;
        let isSaving = false; // Flag to prevent real-time reload during saves

        // Pan and Zoom
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let savedTranslateX = 0;
        let savedTranslateY = 0;
        let savedScale = 1;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Node dragging
        let isDraggingNode = false;
        let draggedNodeId = null;
        let nodeDragStartX = 0;
        let nodeDragStartY = 0;
        let isMovingMode = false;

        // Context menu
        let contextMenuNodeId = null;

        // DOM Elements
        const mapCanvas = document.getElementById('mapCanvas');
        const mapImageContainer = document.getElementById('mapImageContainer');
        const mapList = document.getElementById('mapList');
        const nodeModal = document.getElementById('nodeModal');
        const mapModal = document.getElementById('mapModal');
        const nodeForm = document.getElementById('nodeForm');
        const mapForm = document.getElementById('mapForm');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const modeIndicator = document.getElementById('modeIndicator');

        // Initialize
        async function init() {
            // Don't auto-initialize - wait for login
            // This will be called after authentication
        }

        async function initializeApp() {
            console.log('initializeApp: Starting...');
            showLoading();
            
            console.log('initializeApp: isAdmin =', isAdmin);
            
            // Update UI based on role
            if (isAdmin) {
                console.log('initializeApp: Setting up admin UI');
                document.getElementById('userRole').innerHTML = '<span class="admin-badge">ðŸ›¡ï¸ ADMIN</span>';
                document.getElementById('loginBtn').style.display = 'none';
                document.getElementById('logoutBtn').style.display = 'block';
                enableAdminFeatures();
            } else {
                console.log('initializeApp: Setting up viewer UI');
                document.getElementById('userRole').innerHTML = '<span class="viewer-badge">ðŸ‘ï¸ VIEWER</span>';
                document.getElementById('loginBtn').style.display = 'block';
                document.getElementById('logoutBtn').style.display = 'none';
                disableAdminFeatures();
            }

            // Load data from Supabase
            console.log('initializeApp: Loading data from Supabase...');
            await loadData();
            console.log('initializeApp: Data loaded. Maps count:', maps.length);
            
            if (maps.length === 0 && isAdmin) {
                console.log('initializeApp: No maps found, creating default map');
                createDefaultMap();
                await saveData();
            }

            console.log('initializeApp: Rendering maps...');
            renderMaps();
            if (maps.length > 0) {
                console.log('initializeApp: Selecting first map:', maps[0].name);
                selectMap(maps[0].id);
            }

            console.log('initializeApp: Setting up event listeners...');
            setupEventListeners();
            
            // Setup real-time sync for viewers
            if (!isAdmin) {
                console.log('initializeApp: Setting up real-time sync');
                setupRealtimeSync();
            }

            // Center view
            const rect = mapCanvas.getBoundingClientRect();
            translateX = rect.width / 2;
            translateY = rect.height / 2;
            updateTransform();

            console.log('initializeApp: Complete!');
            hideLoading();
        }

        function enableAdminFeatures() {
            document.getElementById('addNodeBtn').style.display = 'block';
            document.getElementById('addMapBtn').style.display = 'block';
        }

        function disableAdminFeatures() {
            document.getElementById('addNodeBtn').style.display = 'none';
            document.getElementById('addMapBtn').style.display = 'none';
        }

        function setupRealtimeSync() {
            supabaseClient
                .channel('maps-changes')
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'maps' },
                    async () => {
                        console.log('Real-time update received');
                        
                        // Skip reload if we're currently saving (admin operation in progress)
                        if (isSaving) {
                            console.log('Skipping real-time reload - save in progress');
                            return;
                        }
                        
                        await loadData();
                        renderMaps();
                        if (currentMapId) {
                            renderMapCanvas();
                        }
                    }
                )
                .subscribe();
        }

        function createDefaultMap() {
            const defaultMap = {
                id: generateId(),
                name: 'Main Map',
                parentId: null,
                imageUrl: '',
                nodes: []
            };
            maps.push(defaultMap);
            saveData();
        }

        function setupEventListeners() {
            // Add Node Button
            document.getElementById('addNodeBtn').addEventListener('click', () => {
                if (!isAdmin) {
                    alert('Admin access required');
                    return;
                }
                isAddingNode = true;
                modeIndicator.classList.add('active');
                mapCanvas.classList.add('adding-node');
            });

            // Add Map Button
            document.getElementById('addMapBtn').addEventListener('click', () => {
                if (!isAdmin) {
                    alert('Admin access required');
                    return;
                }
                openMapModal();
            });

            // Map Canvas Click
            mapCanvas.addEventListener('click', (e) => {
                if (e.target.classList.contains('node') || e.target.closest('.node')) {
                    return; // Let node handle its own click
                }

                const rect = mapCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Convert canvas coordinates to map coordinates
                const mapX = (canvasX - translateX) / scale;
                const mapY = (canvasY - translateY) / scale;

                console.log('Click position:', { canvasX, canvasY, mapX, mapY, scale, translateX, translateY });

                if (isAddingNode && currentMapId) {
                    pendingNodePosition = { x: mapX, y: mapY };
                    openNodeModal();
                    isAddingNode = false;
                    modeIndicator.classList.remove('active');
                    mapCanvas.classList.remove('adding-node');
                    console.log('Creating node at:', mapX, mapY);
                } else if (isMovingMode && draggedNodeId && currentMapId) {
                    // Move the node to new position
                    const map = maps.find(m => m.id === currentMapId);
                    const node = map?.nodes.find(n => n.id === draggedNodeId);
                    if (node) {
                        node.x = mapX;
                        node.y = mapY;
                        saveData();
                        renderMapCanvas();
                        console.log('Moved node to:', mapX, mapY);
                    }
                    isMovingMode = false;
                    draggedNodeId = null;
                    mapCanvas.style.cursor = '';
                    modeIndicator.classList.remove('active');
                }
            });

            // Pan and Zoom
            mapCanvas.addEventListener('mousedown', startDrag);
            mapCanvas.addEventListener('mousemove', drag);
            mapCanvas.addEventListener('mouseup', endDrag);
            mapCanvas.addEventListener('mouseleave', endDrag);
            mapCanvas.addEventListener('wheel', zoom);

            // Zoom Controls
            document.getElementById('zoomInBtn').addEventListener('click', () => zoomTo(scale * 1.2));
            document.getElementById('zoomOutBtn').addEventListener('click', () => zoomTo(scale / 1.2));
            document.getElementById('zoomResetBtn').addEventListener('click', () => {
                scale = 1;
                const rect = mapCanvas.getBoundingClientRect();
                translateX = rect.width / 2;
                translateY = rect.height / 2;
                updateTransform();
            });

            // Node Modal
            document.getElementById('closeModalBtn').addEventListener('click', closeNodeModal);
            document.getElementById('cancelBtn').addEventListener('click', closeNodeModal);
            nodeForm.addEventListener('submit', saveNode);
            document.getElementById('deleteNodeBtn').addEventListener('click', deleteNode);
            
            // Prevent closing node modal when clicking outside
            nodeModal.addEventListener('click', (e) => {
                // Only close if clicking directly on the modal backdrop, not on modal-content or its children
                if (e.target === nodeModal) {
                    // Do nothing - don't close
                    e.stopPropagation();
                }
            });

            // Map Modal
            document.getElementById('closeMapModalBtn').addEventListener('click', closeMapModal);
            document.getElementById('cancelMapBtn').addEventListener('click', closeMapModal);
            mapForm.addEventListener('submit', saveMap);
            document.getElementById('deleteMapBtn').addEventListener('click', deleteMap);
            
            // Prevent closing map modal when clicking outside
            mapModal.addEventListener('click', (e) => {
                // Only close if clicking directly on the modal backdrop, not on modal-content or its children
                if (e.target === mapModal) {
                    // Do nothing - don't close
                    e.stopPropagation();
                }
            });
            
            // Prevent closing login modal when clicking outside
            const loginModal = document.getElementById('loginModal');
            if (loginModal) {
                loginModal.addEventListener('click', (e) => {
                    if (e.target === loginModal) {
                        e.stopPropagation();
                    }
                });
            }

            // Tags Input (in modal)
            const tagInput = document.getElementById('tagInput');
            if (tagInput) {
                tagInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addTag(e.target.value.trim());
                        e.target.value = '';
                    }
                });
            }

            // Add Variant Button (in modal)
            const addVariantBtn = document.getElementById('addVariantBtn');
            if (addVariantBtn) {
                addVariantBtn.addEventListener('click', addVariant);
            }

            // Show/hide map link based on node type (in modal)
            const nodeTypeSelect = document.getElementById('nodeType');
            if (nodeTypeSelect) {
                nodeTypeSelect.addEventListener('change', (e) => {
                    const mapLinkGroup = document.getElementById('mapLinkGroup');
                    if (e.target.value === 'transition') {
                        mapLinkGroup.style.display = 'block';
                        populateMapLinkDropdown();
                    } else {
                        mapLinkGroup.style.display = 'none';
                    }
                });
            }

            // Search
            searchInput.addEventListener('input', performSearch);
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.classList.remove('active');
                }
            });

            // Context menu
            document.getElementById('contextEdit').addEventListener('click', () => {
                if (contextMenuNodeId) {
                    viewNode(contextMenuNodeId);
                    closeContextMenu();
                }
            });

            document.getElementById('contextMove').addEventListener('click', () => {
                if (contextMenuNodeId) {
                    enterMoveMode(contextMenuNodeId);
                    closeContextMenu();
                }
            });

            document.getElementById('contextDelete').addEventListener('click', () => {
                if (contextMenuNodeId) {
                    deleteNodeQuick(contextMenuNodeId);
                    closeContextMenu();
                }
            });

            // Close context menu on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.context-menu')) {
                    closeContextMenu();
                }
            });

            // Node viewer
            document.getElementById('closeViewerBtn').addEventListener('click', closeNodeViewer);

            // Node moving
            mapCanvas.addEventListener('mousemove', moveNode);
            mapCanvas.addEventListener('mouseup', endMoveNode);
            
            // Disable scroll wheel on number inputs (Fix #13)
            document.addEventListener('wheel', (e) => {
                if (e.target.type === 'number') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Image preview for map upload
            const mapImageFileInput = document.getElementById('mapImageFile');
            if (mapImageFileInput) {
                mapImageFileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        document.getElementById('imagePreviewContainer').style.display = 'none';
                        return;
                    }
                    
                    const previewContainer = document.getElementById('imagePreviewContainer');
                    const preview = document.getElementById('imagePreview');
                    const stats = document.getElementById('imageStats');
                    
                    // Show preview
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        preview.src = e.target.result;
                        previewContainer.style.display = 'block';
                        
                        const originalSize = (file.size / 1024 / 1024).toFixed(2);
                        stats.innerHTML = `
                            Original: ${originalSize} MB<br>
                            <span style="color: var(--primary);">âš¡ Will be compressed on upload</span>
                        `;
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        // Pan and Zoom Functions
        function startDrag(e) {
            if (isAddingNode || isMovingMode || e.target.classList.contains('node') || e.target.closest('.node')) return;
            isDragging = true;
            dragStartX = e.clientX - translateX;
            dragStartY = e.clientY - translateY;
            mapCanvas.classList.add('grabbing');
        }

        function drag(e) {
            if (!isDragging) return;
            translateX = e.clientX - dragStartX;
            translateY = e.clientY - dragStartY;
            updateTransform();
        }

        function endDrag() {
            isDragging = false;
            mapCanvas.classList.remove('grabbing');
        }

        function zoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, scale * delta));
            
            const rect = mapCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldX = (mouseX - translateX) / scale;
            const worldY = (mouseY - translateY) / scale;
            
            translateX = mouseX - worldX * newScale;
            translateY = mouseY - worldY * newScale;
            scale = newScale;
            
            updateTransform();
        }

        function zoomTo(newScale) {
            scale = Math.max(0.1, Math.min(5, newScale));
            updateTransform();
        }

        function updateTransform() {
            mapImageContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // Map Functions
        function renderMaps() {
            mapList.innerHTML = '';
            const rootMaps = maps.filter(m => !m.parentId);
            // Sort by displayOrder
            rootMaps.sort((a, b) => (a.displayOrder || 0) - (b.displayOrder || 0));
            
            // Render all root maps
            rootMaps.forEach(map => {
                renderMapItem(map);
                
                // Find the current map to determine which submaps to show
                const currentMap = maps.find(m => m.id === currentMapId);
                const currentMapParentId = currentMap?.parentId;
                
                // Show submaps if:
                // 1. This map is selected (viewing parent)
                // 2. OR we're viewing a submap of this parent (keep siblings visible)
                if (currentMapId === map.id || currentMapParentId === map.id) {
                    renderSubmaps(map.id, 1);
                }
            });
        }

        function renderMapItem(map, level = 0) {
            const li = document.createElement('li');
            li.className = `map-item ${level > 0 ? 'submap' : ''} ${map.id === currentMapId ? 'active' : ''}`;
            li.style.marginLeft = `${level * 1.5}rem`;
            li.dataset.mapId = map.id;
            li.dataset.parentId = map.parentId || '';
            
            // Make draggable for admins
            if (isAdmin) {
                li.draggable = true;
                li.classList.add('draggable');
            }
            
            const dragHandleHtml = isAdmin ? '<span class="map-drag-handle">â‹®â‹®</span>' : '';
            
            const actionsHtml = isAdmin ? `
                <div class="map-item-actions">
                    <button class="map-action-btn" onclick="event.stopPropagation(); editMap('${map.id}')" title="Edit Map">âœï¸</button>
                    <button class="map-action-btn" onclick="event.stopPropagation(); deleteMapFromSidebar('${map.id}')" title="Delete Map">ðŸ—‘ï¸</button>
                </div>
            ` : '';
            
            // Check if this map has submaps
            const hasSubmaps = maps.some(m => m.parentId === map.id);
            const submapIndicator = hasSubmaps ? ' <span style="opacity: 0.6;">â–¼</span>' : '';
            
            li.innerHTML = `
                ${dragHandleHtml}
                <div class="map-item-name">
                    <span>${map.name}${submapIndicator}</span>
                    ${actionsHtml}
                </div>
                <div class="map-item-count">${map.nodes.length} nodes</div>
            `;
            
            li.addEventListener('click', (e) => {
                if (!e.target.closest('.map-action-btn')) {
                    selectMap(map.id);
                }
            });
            
            // Drag and drop event listeners
            if (isAdmin) {
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragend', handleDragEnd);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('drop', handleDrop);
            }
            
            mapList.appendChild(li);
        }

        function renderSubmaps(parentId, level) {
            const submaps = maps.filter(m => m.parentId === parentId);
            // Sort by displayOrder if it exists
            submaps.sort((a, b) => (a.displayOrder || 0) - (b.displayOrder || 0));
            submaps.forEach(map => {
                renderMapItem(map, level);
                renderSubmaps(map.id, level + 1);
            });
        }

        // ==========================================
        // MAP DRAG AND DROP FUNCTIONS
        // ==========================================
        let draggedMapElement = null;
        let draggedMapId = null;

        function handleDragStart(e) {
            draggedMapElement = e.currentTarget;
            draggedMapId = draggedMapElement.dataset.mapId;
            draggedMapElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedMapElement.innerHTML);
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            
            // Remove all drag-over indicators
            document.querySelectorAll('.map-item').forEach(item => {
                item.classList.remove('drag-over', 'drag-over-bottom');
            });
            
            draggedMapElement = null;
            draggedMapId = null;
        }

        function handleDragOver(e) {
            if (!draggedMapElement) return;
            
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const targetElement = e.currentTarget;
            const targetMapId = targetElement.dataset.mapId;
            const targetParentId = targetElement.dataset.parentId;
            const draggedMap = maps.find(m => m.id === draggedMapId);
            const draggedParentId = draggedMap?.parentId || '';
            
            // Can only reorder within the same parent scope
            if (targetParentId !== draggedParentId) {
                return;
            }
            
            // Don't allow dropping on itself
            if (targetMapId === draggedMapId) {
                return;
            }
            
            // Determine if we should show indicator above or below
            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            targetElement.classList.remove('drag-over', 'drag-over-bottom');
            
            if (e.clientY < midpoint) {
                targetElement.classList.add('drag-over');
            } else {
                targetElement.classList.add('drag-over-bottom');
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!draggedMapId) return;
            
            const targetElement = e.currentTarget;
            const targetMapId = targetElement.dataset.mapId;
            const targetParentId = targetElement.dataset.parentId;
            const draggedMap = maps.find(m => m.id === draggedMapId);
            const draggedParentId = draggedMap?.parentId || '';
            
            // Can only reorder within the same parent scope
            if (targetParentId !== draggedParentId) {
                return;
            }
            
            if (targetMapId === draggedMapId) {
                return;
            }
            
            // Determine insert position based on drop location
            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const insertBefore = e.clientY < midpoint;
            
            // Reorder maps
            reorderMaps(draggedMapId, targetMapId, insertBefore, draggedParentId);
            
            // Clean up
            targetElement.classList.remove('drag-over', 'drag-over-bottom');
        }

        function reorderMaps(draggedId, targetId, insertBefore, parentId) {
            console.log('=== REORDER MAPS ===');
            console.log('Dragged:', draggedId, 'Target:', targetId, 'Insert before:', insertBefore, 'Parent:', parentId);
            
            // Get all maps with the same parent
            const siblingMaps = maps.filter(m => (m.parentId || '') === parentId);
            
            // Sort by current display order
            siblingMaps.sort((a, b) => (a.displayOrder || 0) - (b.displayOrder || 0));
            
            console.log('Before reorder:', siblingMaps.map(m => `${m.name}(${m.displayOrder})`).join(', '));
            
            // Find indices
            const draggedIndex = siblingMaps.findIndex(m => m.id === draggedId);
            const targetIndex = siblingMaps.findIndex(m => m.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) {
                console.error('Map not found in siblings');
                return;
            }
            
            // Remove dragged item
            const [draggedMap] = siblingMaps.splice(draggedIndex, 1);
            
            // Calculate new target index after removal
            const newTargetIndex = siblingMaps.findIndex(m => m.id === targetId);
            
            // Insert at new position
            const insertIndex = insertBefore ? newTargetIndex : newTargetIndex + 1;
            siblingMaps.splice(insertIndex, 0, draggedMap);
            
            // Update display orders
            siblingMaps.forEach((map, index) => {
                map.displayOrder = index;
            });
            
            console.log('After reorder:', siblingMaps.map(m => `${m.name}(${m.displayOrder})`).join(', '));
            
            // Save to database
            console.log('Saving to database...');
            saveData().then(() => {
                console.log('Save complete, rendering maps...');
                renderMaps();
            }).catch(error => {
                console.error('Save failed:', error);
            });
        }

        function selectMap(mapId, onMapLoaded = null) {
            currentMapId = mapId;
            renderMaps();
            renderMapCanvas(onMapLoaded);
        }

        function renderMapCanvas(onMapLoaded = null) {
            const map = maps.find(m => m.id === currentMapId);
            if (!map) {
                console.log('No map found for currentMapId:', currentMapId);
                return;
            }

            console.log('Rendering map:', map.name, 'with', map.nodes.length, 'nodes');

            // Clear existing nodes
            const existingNodes = mapImageContainer.querySelectorAll('.node');
            existingNodes.forEach(node => node.remove());

            // Render map image if exists
            let img = mapImageContainer.querySelector('.map-image');
            
            if (map.imageUrl) {
                if (!img) {
                    img = document.createElement('img');
                    img.className = 'map-image';
                    img.loading = 'lazy'; // Enable lazy loading
                    mapImageContainer.appendChild(img);
                }
                
                // If image is already loaded (cached), call callback immediately
                if (img.src === map.imageUrl && img.complete) {
                    console.log('Map image already loaded (cached)');
                    if (onMapLoaded) onMapLoaded();
                } else {
                    img.src = map.imageUrl;
                    img.style.display = 'block';
                    img.onload = () => {
                        console.log('Map image loaded:', img.naturalWidth, 'x', img.naturalHeight);
                        // Center the view on the actual center of the image
                        const rect = mapCanvas.getBoundingClientRect();
                        const imageWidth = img.naturalWidth;
                        const imageHeight = img.naturalHeight;
                        
                        // Calculate translation to center the image in the viewport
                        translateX = (rect.width / 2) - (imageWidth / 2);
                        translateY = (rect.height / 2) - (imageHeight / 2);
                        updateTransform();
                        
                        // Call callback after image is loaded and centered
                        if (onMapLoaded) onMapLoaded();
                    };
                }
            } else if (img) {
                img.style.display = 'none';
                // No image, call callback immediately
                if (onMapLoaded) onMapLoaded();
            } else {
                // No image at all, call callback immediately
                if (onMapLoaded) onMapLoaded();
            }

            // Render nodes
            console.log('About to render', map.nodes.length, 'nodes');
            map.nodes.forEach(node => {
                console.log('Rendering node:', node.name, 'at position', node.x, node.y);
                renderNode(node);
            });
        }

        function renderNode(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            nodeEl.dataset.nodeId = node.id;
            nodeEl.innerHTML = `<div class="node-icon node-${node.type}">${getNodeIcon(node.type)}</div>`;
            
            // Click to view
            nodeEl.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isDraggingNode && !isMovingMode) {
                    viewNode(node.id);
                }
            });
            
            // Right-click context menu
            nodeEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showNodeContextMenu(e, node.id);
            });
            
            mapImageContainer.appendChild(nodeEl);
            console.log('Rendered node:', node.name, 'at map coords:', node.x, node.y, 'Current transform:', { scale, translateX, translateY });
        }

        function getNodeIcon(type) {
            const icons = {
                combat: 'âš”ï¸',
                event: 'ðŸ“œ',
                card: 'ðŸŽ´',
                crafter: 'ðŸ”¨',
                rest: 'ðŸ›ï¸',
                character: 'ðŸ‘¤',
                transition: 'ðŸšª',
                shop: 'ðŸª',
                quest: 'â“',
                rift: 'ðŸŒ€',
                boss: 'ðŸ‘¹',
                information: 'â„¹ï¸'
            };
            const icon = icons[type] || 'â­';
            console.log('Getting icon for type:', type, 'â†’', icon);
            return icon;
        }

        // Node Modal Functions
        function openNodeModal(node = null) {
            if (!isAdmin) {
                alert('Admin access required to edit nodes');
                return;
            }

            // Save current view position
            savedTranslateX = translateX;
            savedTranslateY = translateY;
            savedScale = scale;

            editingNodeId = node ? node.id : null;
            const modalTitle = document.getElementById('modalTitle');
            const deleteBtn = document.getElementById('deleteNodeBtn');
            const mapLinkGroup = document.getElementById('mapLinkGroup');

            if (node) {
                modalTitle.textContent = 'Edit Node';
                deleteBtn.style.display = 'block';
                
                // Populate node name
                document.getElementById('nodeName').value = node.name;
                
                // Load variants from node
                if (node.variants && node.variants.length > 0) {
                    currentNodeVariants = JSON.parse(JSON.stringify(node.variants)); // Deep copy
                    currentVariantIndex = 0;
                } else {
                    // Convert old single-variant nodes to variant format
                    currentNodeVariants = [{
                        name: 'Combat',
                        chance: 100,
                        type: node.type,
                        description: node.description || '',
                        mapLink: node.mapLink || null,
                        tags: [...(node.tags || [])],
                        options: JSON.parse(JSON.stringify(node.options || []))
                    }];
                    currentVariantIndex = 0;
                }
                
                renderVariantTabs();
                switchToVariant(0, true); // Skip save on initial load
                
                // Show map link if current variant is a transition
                if (currentNodeVariants[0].type === 'transition') {
                    mapLinkGroup.style.display = 'block';
                    populateMapLinkDropdown();
                } else {
                    mapLinkGroup.style.display = 'none';
                }
            } else {
                modalTitle.textContent = 'Create New Node';
                deleteBtn.style.display = 'none';
                nodeForm.reset();
                document.getElementById('nodeName').value = ''; // Clear node name
                initializeVariants();
                mapLinkGroup.style.display = 'none';
            }

            nodeModal.classList.add('active');
            
            // Scroll modal content to top
            const modalContent = nodeModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.scrollTop = 0;
            }
        }

        function closeNodeModal() {
            nodeModal.classList.remove('active');
            editingNodeId = null;
            pendingNodePosition = null;
            nodeForm.reset();
            
            // Restore saved view position
            translateX = savedTranslateX;
            translateY = savedTranslateY;
            scale = savedScale;
            updateTransform();
        }

        function populateNodeForm(node) {
            document.getElementById('nodeName').value = node.name;
            document.getElementById('nodeType').value = node.type;
            document.getElementById('nodeDescription').value = node.description || '';
            
            // Populate map link if it exists
            if (node.mapLink) {
                document.getElementById('nodeMapLink').value = node.mapLink;
            }
            
            // Clear and populate tags
            const tagsContainer = document.getElementById('tagsContainer');
            const existingTags = tagsContainer.querySelectorAll('.tag');
            existingTags.forEach(tag => tag.remove());
            node.tags.forEach(tag => addTag(tag));

            // Clear and populate options
            resetOptions();
            if (node.options && node.options.length > 0) {
                const optionsContainer = document.getElementById('optionsContainer');
                optionsContainer.innerHTML = '';
                node.options.forEach((option, index) => {
                    const optionHtml = createOptionHtml(index + 1, option);
                    optionsContainer.insertAdjacentHTML('beforeend', optionHtml);
                });
            }
        }

        function populateMapLinkDropdown() {
            const select = document.getElementById('nodeMapLink');
            select.innerHTML = '<option value="">None</option>';
            
            maps.forEach(map => {
                const option = document.createElement('option');
                option.value = map.id;
                option.textContent = map.name;
                select.appendChild(option);
            });
        }

        function saveNode(e) {
            e.preventDefault();
            
            const map = maps.find(m => m.id === currentMapId);
            if (!map) return;

            // Save current variant data before saving node
            saveCurrentVariantData();

            const nodeData = {
                id: editingNodeId || generateId(),
                name: document.getElementById('nodeName').value,
                variants: JSON.parse(JSON.stringify(currentNodeVariants)), // Save all variants
                x: 0,
                y: 0,
                
                // Keep legacy fields for backward compatibility (use first variant)
                type: currentNodeVariants[0].type,
                description: currentNodeVariants[0].description,
                mapLink: currentNodeVariants[0].mapLink,
                tags: currentNodeVariants[0].tags,
                options: currentNodeVariants[0].options
            };

            if (editingNodeId) {
                // Update existing node
                const nodeIndex = map.nodes.findIndex(n => n.id === editingNodeId);
                if (nodeIndex !== -1) {
                    nodeData.x = map.nodes[nodeIndex].x;
                    nodeData.y = map.nodes[nodeIndex].y;
                    map.nodes[nodeIndex] = nodeData;
                }
            } else {
                // Create new node
                if (pendingNodePosition) {
                    nodeData.x = pendingNodePosition.x;
                    nodeData.y = pendingNodePosition.y;
                }
                map.nodes.push(nodeData);
            }

            saveData();
            renderMapCanvas();
            closeNodeModal();
        }

        function editNode(nodeId) {
            const map = maps.find(m => m.id === currentMapId);
            const node = map?.nodes.find(n => n.id === nodeId);
            if (node) {
                closeNodeViewer(); // Close viewer when opening editor
                openNodeModal(node);
            }
        }

        // Node Viewer Functions
        function viewNode(nodeId) {
            const map = maps.find(m => m.id === currentMapId);
            const node = map?.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Save current view position
            savedTranslateX = translateX;
            savedTranslateY = translateY;
            savedScale = scale;

            viewingNodeId = nodeId;
            
            document.getElementById('viewerNodeName').textContent = node.name;
            
            const content = document.getElementById('viewerContent');
            let html = '';

            // Check if node has variants
            const hasVariants = node.variants && node.variants.length > 0;
            const variants = hasVariants ? node.variants : [{
                name: 'Combat',
                chance: 100,
                type: node.type,
                description: node.description,
                mapLink: node.mapLink,
                tags: node.tags || [],
                options: node.options || []
            }];

            // Show variant tabs if there are multiple variants
            if (variants.length > 1) {
                html += `
                    <div class="node-viewer-section">
                        <div class="node-viewer-label">Variants (${variants.length} possible encounters)</div>
                        <div class="viewer-variant-tabs" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.75rem;">
                            ${variants.map((v, idx) => `
                                <button class="btn btn-secondary btn-small viewer-variant-tab ${idx === 0 ? 'active' : ''}" 
                                        onclick="switchViewerVariant(${idx})" 
                                        data-variant-idx="${idx}"
                                        style="font-size: 0.85rem;">
                                    ${v.name} (${v.chance}%)
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Display each variant's content (only show first by default)
            variants.forEach((variant, variantIdx) => {
                const variantHtml = [];
                const isVisible = variantIdx === 0;
                
                variantHtml.push(`<div class="viewer-variant-content" data-variant-idx="${variantIdx}" style="display: ${isVisible ? 'block' : 'none'};">`);

                // Node Type - only show for transitions (other types implied by options)
                if (variant.type === 'transition') {
                    const typeClass = `node-${variant.type}`;
                    const typeIcon = getNodeIcon(variant.type);
                    variantHtml.push(`<div class="node-viewer-type ${typeClass}">${typeIcon} ${formatNodeType(variant.type)}</div>`);
                }

                // Linked Map (for transitions)
                if (variant.mapLink) {
                    const linkedMap = maps.find(m => m.id === variant.mapLink);
                    if (linkedMap) {
                        variantHtml.push(`
                            <div class="node-viewer-section">
                                <div class="node-viewer-label">Transitions To</div>
                                <button class="btn btn-primary" style="width: 100%; margin-top: 0.5rem;" onclick="goToLinkedMap('${variant.mapLink}')">
                                    ðŸšª Go to ${linkedMap.name}
                                </button>
                            </div>
                        `);
                    }
                }

                // Description
                if (variant.description) {
                    variantHtml.push(`
                        <div class="node-viewer-section">
                            <div class="node-viewer-label">Description</div>
                            <div class="node-viewer-content" style="white-space: pre-wrap;">${variant.description}</div>
                        </div>
                    `);
                }

                // Tags
                if (variant.tags && variant.tags.length > 0) {
                    variantHtml.push(`
                        <div class="node-viewer-section">
                            <div class="node-viewer-label">Tags</div>
                            <div class="node-viewer-tags">
                                ${variant.tags.map(tag => `<span class="node-viewer-tag">${tag}</span>`).join('')}
                            </div>
                        </div>
                    `);
                }

                // Options
                if (variant.options && variant.options.length > 0) {
                    variantHtml.push(`<div class="node-viewer-section">
                        <div class="node-viewer-label">Options</div>`);
                    
                    variant.options.forEach((option, index) => {
                        const optionId = `option-${index}-${Math.random().toString(36).substr(2, 9)}`;
                        variantHtml.push(`
                            <div class="node-viewer-option" style="cursor: pointer; border: 1px solid rgba(139, 115, 85, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 0.5rem;" onclick="toggleOptionContent('${optionId}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div class="node-viewer-option-label" style="margin: 0;">${index + 1}. ${option.label || 'Unnamed Option'}</div>
                                    <span id="${optionId}-toggle" style="font-size: 0.9rem; opacity: 0.6;">â–¶</span>
                                </div>
                                <div id="${optionId}-content" style="display: none; margin-top: 0.75rem;">
                        `);
                        
                        if (option.description) {
                            variantHtml.push(`<div class="node-viewer-option-desc" style="word-wrap: break-word; overflow-wrap: break-word;">${option.description}</div>`);
                        }
                        
                        const rewards = [];
                        if (option.gold && option.gold !== 0) rewards.push(`<span class="node-viewer-reward">ðŸ’° ${option.gold}</span>`);
                        if (option.shards && option.shards !== 0) rewards.push(`<span class="node-viewer-reward">ðŸ’Ž ${option.shards}</span>`);
                        if (option.exp && option.exp !== 0) rewards.push(`<span class="node-viewer-reward">â­ ${option.exp}</span>`);
                        
                        if (rewards.length > 0) {
                            variantHtml.push(`<div class="node-viewer-rewards">${rewards.join('')}</div>`);
                        }
                        
                        // Display structured success/fail outcomes if present
                        const hasStructuredOutcomes = option.onSuccess || option.onCritSuccess || option.onFail || option.onCritFail;
                        
                        if (hasStructuredOutcomes) {
                            variantHtml.push(`
                                <div style="margin-top: 0.75rem;">
                            `);
                            
                            if (option.onSuccess || option.successGold || option.successShards || option.successExp) {
                                variantHtml.push(`
                                    <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(74, 222, 128, 0.1); border-left: 3px solid #4ade80; border-radius: 4px;">
                                        <div style="color: #4ade80; font-weight: 600; font-size: 0.85rem; margin-bottom: 0.25rem;">âœ“ Success</div>
                                `);
                                if (option.onSuccess) {
                                    variantHtml.push(`<div style="color: rgba(245, 230, 211, 0.85); font-size: 0.85rem; margin-bottom: 0.25rem;">${option.onSuccess}</div>`);
                                }
                                const successRewards = [];
                                if (option.successGold && option.successGold !== 0) successRewards.push(`ðŸ’° ${option.successGold}`);
                                if (option.successShards && option.successShards !== 0) successRewards.push(`ðŸ’Ž ${option.successShards}`);
                                if (option.successExp && option.successExp !== 0) successRewards.push(`â­ ${option.successExp}`);
                                if (successRewards.length > 0) {
                                    variantHtml.push(`<div style="font-size: 0.85rem; color: rgba(245, 230, 211, 0.7);">${successRewards.join(' ')}</div>`);
                                }
                                variantHtml.push(`</div>`);
                            }
                            
                            if (option.onCritSuccess || option.critSuccessGold || option.critSuccessShards || option.critSuccessExp) {
                                variantHtml.push(`
                                    <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(96, 165, 250, 0.1); border-left: 3px solid #60a5fa; border-radius: 4px;">
                                        <div style="color: #60a5fa; font-weight: 600; font-size: 0.85rem; margin-bottom: 0.25rem;">â˜… Critical Success</div>
                                `);
                                if (option.onCritSuccess) {
                                    variantHtml.push(`<div style="color: rgba(245, 230, 211, 0.85); font-size: 0.85rem; margin-bottom: 0.25rem;">${option.onCritSuccess}</div>`);
                                }
                                const critSuccessRewards = [];
                                if (option.critSuccessGold && option.critSuccessGold !== 0) critSuccessRewards.push(`ðŸ’° ${option.critSuccessGold}`);
                                if (option.critSuccessShards && option.critSuccessShards !== 0) critSuccessRewards.push(`ðŸ’Ž ${option.critSuccessShards}`);
                                if (option.critSuccessExp && option.critSuccessExp !== 0) critSuccessRewards.push(`â­ ${option.critSuccessExp}`);
                                if (critSuccessRewards.length > 0) {
                                    variantHtml.push(`<div style="font-size: 0.85rem; color: rgba(245, 230, 211, 0.7);">${critSuccessRewards.join(' ')}</div>`);
                                }
                                variantHtml.push(`</div>`);
                            }
                            
                            if (option.onFail || option.failGold || option.failShards || option.failExp) {
                                variantHtml.push(`
                                    <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(251, 146, 60, 0.1); border-left: 3px solid #fb923c; border-radius: 4px;">
                                        <div style="color: #fb923c; font-weight: 600; font-size: 0.85rem; margin-bottom: 0.25rem;">âœ— Fail</div>
                                `);
                                if (option.onFail) {
                                    variantHtml.push(`<div style="color: rgba(245, 230, 211, 0.85); font-size: 0.85rem; margin-bottom: 0.25rem;">${option.onFail}</div>`);
                                }
                                const failRewards = [];
                                if (option.failGold && option.failGold !== 0) failRewards.push(`ðŸ’° ${option.failGold}`);
                                if (option.failShards && option.failShards !== 0) failRewards.push(`ðŸ’Ž ${option.failShards}`);
                                if (option.failExp && option.failExp !== 0) failRewards.push(`â­ ${option.failExp}`);
                                if (failRewards.length > 0) {
                                    variantHtml.push(`<div style="font-size: 0.85rem; color: rgba(245, 230, 211, 0.7);">${failRewards.join(' ')}</div>`);
                                }
                                variantHtml.push(`</div>`);
                            }
                            
                            if (option.onCritFail || option.critFailGold || option.critFailShards || option.critFailExp) {
                                variantHtml.push(`
                                    <div style="padding: 0.5rem; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 4px;">
                                        <div style="color: #ef4444; font-weight: 600; font-size: 0.85rem; margin-bottom: 0.25rem;">â˜  Critical Fail</div>
                                `);
                                if (option.onCritFail) {
                                    variantHtml.push(`<div style="color: rgba(245, 230, 211, 0.85); font-size: 0.85rem; margin-bottom: 0.25rem;">${option.onCritFail}</div>`);
                                }
                                const critFailRewards = [];
                                if (option.critFailGold && option.critFailGold !== 0) critFailRewards.push(`ðŸ’° ${option.critFailGold}`);
                                if (option.critFailShards && option.critFailShards !== 0) critFailRewards.push(`ðŸ’Ž ${option.critFailShards}`);
                                if (option.critFailExp && option.critFailExp !== 0) critFailRewards.push(`â­ ${option.critFailExp}`);
                                if (critFailRewards.length > 0) {
                                    variantHtml.push(`<div style="font-size: 0.85rem; color: rgba(245, 230, 211, 0.7);">${critFailRewards.join(' ')}</div>`);
                                }
                                variantHtml.push(`</div>`);
                            }
                            
                            variantHtml.push(`</div>`);
                        }
                        
                        // Display general outcomes notes if present
                        if (option.outcomes && option.outcomes.trim()) {
                            variantHtml.push(`
                                <div style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(42, 35, 26, 0.3); border-radius: 6px; border-left: 3px solid var(--accent);">
                                    <div style="font-size: 0.85rem; color: var(--accent); font-weight: 600; margin-bottom: 0.5rem;">
                                        ðŸ“ Additional Notes
                                    </div>
                                    <div style="color: rgba(245, 230, 211, 0.85); font-size: 0.9rem; white-space: pre-wrap; padding-left: 0;">
                                        ${option.outcomes}
                                    </div>
                                </div>
                            `);
                        }
                        
                        // Display follow-up events
                        if (option.followupEvents && option.followupEvents.length > 0) {
                            variantHtml.push(`
                                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(139, 115, 85, 0.3);">
                                    <div style="font-size: 0.85rem; color: var(--primary); font-weight: 600; margin-bottom: 0.5rem;">
                                        â†“ Follow-up Events (${option.followupEvents.length})
                                    </div>
                            `);
                            
                            option.followupEvents.forEach((event, eventIdx) => {
                                variantHtml.push(`
                                    <div style="background: rgba(42, 35, 26, 0.3); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.5rem; border-left: 3px solid var(--primary);">
                                        <div style="font-weight: 600; color: var(--primary); font-size: 0.9rem; margin-bottom: 0.25rem;">
                                            ${eventIdx + 1}. ${event.name}
                                        </div>
                                `);
                                
                                if (event.description) {
                                    variantHtml.push(`
                                        <div style="color: rgba(245, 230, 211, 0.8); font-size: 0.85rem; margin-bottom: 0.5rem;">
                                            ${event.description}
                                        </div>
                                    `);
                                }
                                
                                const eventRewards = [];
                                if (event.gold && event.gold !== 0) eventRewards.push(`<span class="node-viewer-reward">ðŸ’° ${event.gold}</span>`);
                                if (event.shards && event.shards !== 0) eventRewards.push(`<span class="node-viewer-reward">ðŸ’Ž ${event.shards}</span>`);
                                if (event.exp && event.exp !== 0) eventRewards.push(`<span class="node-viewer-reward">â­ ${event.exp}</span>`);
                                
                                if (eventRewards.length > 0) {
                                    variantHtml.push(`<div class="node-viewer-rewards">${eventRewards.join('')}</div>`);
                                }
                                
                                variantHtml.push(`</div>`);
                            });
                            
                            variantHtml.push(`</div>`);
                        }
                        
                        variantHtml.push(`</div></div>`); // Close content div and option div
                    });
                    
                    variantHtml.push(`</div>`);
                }

                variantHtml.push(`</div>`);
                html += variantHtml.join('');
            });

            // Actions
            if (isAdmin) {
                html += `
                    <div class="node-viewer-actions">
                        <button class="btn btn-primary btn-small" onclick="editNodeFromViewer()">âœï¸ Edit</button>
                        <button class="btn btn-secondary btn-small" onclick="moveNodeFromViewer()">â†”ï¸ Move</button>
                        <button class="btn btn-danger btn-small" onclick="deleteNodeFromViewer()">ðŸ—‘ï¸ Delete</button>
                    </div>
                `;
            }

            content.innerHTML = html;
            document.getElementById('nodeViewer').classList.add('active');
        }

        function switchViewerVariant(index) {
            // Hide all variant contents
            document.querySelectorAll('.viewer-variant-content').forEach(el => {
                el.style.display = 'none';
            });
            
            // Show selected variant
            const targetContent = document.querySelector(`.viewer-variant-content[data-variant-idx="${index}"]`);
            if (targetContent) {
                targetContent.style.display = 'block';
            }
            
            // Update active tab
            document.querySelectorAll('.viewer-variant-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const activeTab = document.querySelector(`.viewer-variant-tab[data-variant-idx="${index}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
        }

        function closeNodeViewer() {
            document.getElementById('nodeViewer').classList.remove('active');
            viewingNodeId = null;
            
            // Restore saved view position
            translateX = savedTranslateX;
            translateY = savedTranslateY;
            scale = savedScale;
            updateTransform();
        }

        function toggleOptionContent(optionId) {
            const content = document.getElementById(`${optionId}-content`);
            const toggle = document.getElementById(`${optionId}-toggle`);
            
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.textContent = 'â–¼';
                } else {
                    content.style.display = 'none';
                    toggle.textContent = 'â–¶';
                }
            }
        }

        function formatNodeType(type) {
            const typeMap = {
                combat: 'Combat',
                event: 'Event (Rarity)',
                card: 'Card Node',
                crafter: 'Crafter Node',
                rest: 'Rest Node',
                character: 'Character',
                transition: 'Map Transition',
                shop: 'Shop',
                quest: 'Quest End',
                rift: 'Eldritch Rift',
                boss: 'Region Boss',
                information: 'Information'
            };
            return typeMap[type] || type;
        }

        // Actions from viewer
        function editNodeFromViewer() {
            if (viewingNodeId) {
                editNode(viewingNodeId);
            }
        }

        function moveNodeFromViewer() {
            if (viewingNodeId) {
                enterMoveMode(viewingNodeId);
                closeNodeViewer();
            }
        }

        function deleteNodeFromViewer() {
            if (viewingNodeId) {
                deleteNodeQuick(viewingNodeId);
                closeNodeViewer();
            }
        }

        function goToLinkedMap(mapId) {
            closeNodeViewer();
            selectMap(mapId);
        }

        function deleteNode() {
            if (!editingNodeId || !confirm('Are you sure you want to delete this node?')) return;

            const map = maps.find(m => m.id === currentMapId);
            if (map) {
                map.nodes = map.nodes.filter(n => n.id !== editingNodeId);
                saveData();
                renderMapCanvas();
                closeNodeModal();
            }
        }

        function deleteNodeQuick(nodeId) {
            if (!isAdmin) {
                alert('Admin access required to delete nodes');
                return;
            }
            if (!confirm('Are you sure you want to delete this node?')) return;

            const map = maps.find(m => m.id === currentMapId);
            if (map) {
                map.nodes = map.nodes.filter(n => n.id !== nodeId);
                saveData();
                renderMapCanvas();
            }
        }

        // Context Menu Functions
        function showNodeContextMenu(e, nodeId) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenuNodeId = nodeId;
            
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            contextMenu.classList.add('active');
        }

        function closeContextMenu() {
            document.getElementById('contextMenu').classList.remove('active');
            contextMenuNodeId = null;
        }

        // Node Moving Functions
        function enterMoveMode(nodeId) {
            if (!isAdmin) {
                alert('Admin access required to move nodes');
                return;
            }

            isMovingMode = true;
            draggedNodeId = nodeId;
            mapCanvas.style.cursor = 'move';
            modeIndicator.textContent = 'Click on the map to place the node in new location';
            modeIndicator.classList.add('active');
            
            // Highlight the node being moved
            const nodeEl = mapImageContainer.querySelector(`[data-node-id="${nodeId}"]`);
            if (nodeEl) {
                nodeEl.classList.add('highlighted');
            }
        }

        function moveNode(e) {
            // This is handled by clicking instead of dragging for better control
        }

        function endMoveNode() {
            // Handled by click event
        }

        // Tags Functions
        function addTag(tagText) {
            if (!tagText) return;
            
            const tagsContainer = document.getElementById('tagsContainer');
            const tagInput = document.getElementById('tagInput');
            
            const tag = document.createElement('div');
            tag.className = 'tag';
            tag.draggable = true;
            tag.innerHTML = `
                <span class="tag-drag-handle" style="opacity: 0.5; margin-right: 4px; cursor: grab;">â‹®â‹®</span>
                ${tagText}
                <span class="tag-remove" onclick="this.parentElement.remove()">Ã—</span>
            `;
            
            // Add drag event listeners
            tag.addEventListener('dragstart', handleTagDragStart);
            tag.addEventListener('dragend', handleTagDragEnd);
            tag.addEventListener('dragover', handleTagDragOver);
            tag.addEventListener('drop', handleTagDrop);
            
            tagsContainer.insertBefore(tag, tagInput);
        }
        
        let draggedTag = null;
        
        function handleTagDragStart(e) {
            draggedTag = e.target;
            e.target.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleTagDragEnd(e) {
            e.target.style.opacity = '1';
            // Remove all drag-over indicators
            document.querySelectorAll('.tag').forEach(tag => {
                tag.style.borderLeft = '';
                tag.style.borderRight = '';
            });
        }
        
        function handleTagDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const targetTag = e.target.closest('.tag');
            if (!targetTag || targetTag === draggedTag) return;
            
            // Remove previous indicators
            document.querySelectorAll('.tag').forEach(tag => {
                tag.style.borderLeft = '';
                tag.style.borderRight = '';
            });
            
            // Determine if we should insert before or after
            const rect = targetTag.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            
            if (e.clientX < midpoint) {
                targetTag.style.borderLeft = '2px solid var(--primary)';
            } else {
                targetTag.style.borderRight = '2px solid var(--primary)';
            }
            
            return false;
        }
        
        function handleTagDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const targetTag = e.target.closest('.tag');
            if (!targetTag || !draggedTag || targetTag === draggedTag) return;
            
            const tagsContainer = document.getElementById('tagsContainer');
            const rect = targetTag.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            
            // Insert before or after based on drop position
            if (e.clientX < midpoint) {
                tagsContainer.insertBefore(draggedTag, targetTag);
            } else {
                tagsContainer.insertBefore(draggedTag, targetTag.nextSibling);
            }
            
            // Clean up styling
            targetTag.style.borderLeft = '';
            targetTag.style.borderRight = '';
            
            return false;
        }

        function getTags() {
            const tags = [];
            document.querySelectorAll('.tag').forEach(tag => {
                const text = tag.textContent.replace('Ã—', '').replace('â‹®â‹®', '').trim();
                if (text) tags.push(text);
            });
            return tags;
        }

        // Options Functions
        function resetOptions() {
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = createOptionHtml(1);
        }

        function createOptionHtml(number, option = null) {
            const followupEventsHtml = option?.followupEvents && option.followupEvents.length > 0
                ? option.followupEvents.map((event, idx) => createFollowupEventHtml(idx, event)).join('')
                : '';
            
            return `
                <div class="option-item">
                    <div class="option-header">
                        <span class="option-number">Option ${number}</span>
                        <button type="button" class="option-remove" onclick="removeOption(this)">Remove</button>
                    </div>
                    <input type="text" class="form-input" placeholder="Option label (e.g., 'Talk', 'Buy', 'Fight')" data-option="label" value="${option?.label || ''}">
                    <input type="text" class="form-input" placeholder="Option description (optional)" data-option="description" style="margin-top: 0.5rem;" value="${option?.description || ''}">
                    <div class="rewards-row">
                        <input type="number" class="form-input" placeholder="Gold" data-option="gold" value="${option?.gold !== undefined && option.gold !== 0 ? option.gold : ''}">
                        <input type="number" class="form-input" placeholder="Shards" data-option="shards" value="${option?.shards !== undefined && option.shards !== 0 ? option.shards : ''}">
                        <input type="number" class="form-input" placeholder="EXP" data-option="exp" value="${option?.exp !== undefined && option.exp !== 0 ? option.exp : ''}">
                    </div>
                    
                    <!-- Expandable Success/Fail Outcomes -->
                    <div style="margin-top: 1rem;">
                        <button type="button" class="btn btn-secondary btn-small" onclick="toggleOutcomes(this)" style="width: 100%;">
                            <span class="toggle-icon">â–¶</span> Success/Fail Outcomes
                        </button>
                        <div class="outcomes-section" style="display: none; margin-top: 0.75rem; padding: 1rem; background: rgba(42, 35, 26, 0.3); border-radius: 6px;">
                            <div style="margin-bottom: 1rem;">
                                <label class="form-label" style="font-size: 0.9rem; color: #4ade80;">âœ“ On Success</label>
                                <textarea class="form-textarea" placeholder="What happens on success..." data-option="onSuccess" style="min-height: 60px; margin-top: 0.5rem;">${option?.onSuccess || ''}</textarea>
                                <div class="rewards-row" style="margin-top: 0.5rem;">
                                    <input type="number" class="form-input" placeholder="Gold" data-option="successGold" value="${option?.successGold !== undefined && option.successGold !== 0 ? option.successGold : ""}">
                                    <input type="number" class="form-input" placeholder="Shards" data-option="successShards" value="${option?.successShards !== undefined && option.successShards !== 0 ? option.successShards : ""}">
                                    <input type="number" class="form-input" placeholder="EXP" data-option="successExp" value="${option?.successExp !== undefined && option.successExp !== 0 ? option.successExp : ""}">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label class="form-label" style="font-size: 0.9rem; color: #60a5fa;">â˜… On Critical Success</label>
                                <textarea class="form-textarea" placeholder="What happens on critical success..." data-option="onCritSuccess" style="min-height: 60px; margin-top: 0.5rem;">${option?.onCritSuccess || ''}</textarea>
                                <div class="rewards-row" style="margin-top: 0.5rem;">
                                    <input type="number" class="form-input" placeholder="Gold" data-option="critSuccessGold" value="${option?.critSuccessGold !== undefined && option.critSuccessGold !== 0 ? option.critSuccessGold : ""}">
                                    <input type="number" class="form-input" placeholder="Shards" data-option="critSuccessShards" value="${option?.critSuccessShards !== undefined && option.critSuccessShards !== 0 ? option.critSuccessShards : ""}">
                                    <input type="number" class="form-input" placeholder="EXP" data-option="critSuccessExp" value="${option?.critSuccessExp !== undefined && option.critSuccessExp !== 0 ? option.critSuccessExp : ""}">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label class="form-label" style="font-size: 0.9rem; color: #fb923c;">âœ— On Fail</label>
                                <textarea class="form-textarea" placeholder="What happens on fail..." data-option="onFail" style="min-height: 60px; margin-top: 0.5rem;">${option?.onFail || ''}</textarea>
                                <div class="rewards-row" style="margin-top: 0.5rem;">
                                    <input type="number" class="form-input" placeholder="Gold" data-option="failGold" value="${option?.failGold !== undefined && option.failGold !== 0 ? option.failGold : ""}">
                                    <input type="number" class="form-input" placeholder="Shards" data-option="failShards" value="${option?.failShards !== undefined && option.failShards !== 0 ? option.failShards : ""}">
                                    <input type="number" class="form-input" placeholder="EXP" data-option="failExp" value="${option?.failExp !== undefined && option.failExp !== 0 ? option.failExp : ""}">
                                </div>
                            </div>
                            
                            <div>
                                <label class="form-label" style="font-size: 0.9rem; color: #ef4444;">â˜  On Critical Fail</label>
                                <textarea class="form-textarea" placeholder="What happens on critical fail..." data-option="onCritFail" style="min-height: 60px; margin-top: 0.5rem;">${option?.onCritFail || ''}</textarea>
                                <div class="rewards-row" style="margin-top: 0.5rem;">
                                    <input type="number" class="form-input" placeholder="Gold" data-option="critFailGold" value="${option?.critFailGold !== undefined && option.critFailGold !== 0 ? option.critFailGold : ""}">
                                    <input type="number" class="form-input" placeholder="Shards" data-option="critFailShards" value="${option?.critFailShards !== undefined && option.critFailShards !== 0 ? option.critFailShards : ""}">
                                    <input type="number" class="form-input" placeholder="EXP" data-option="critFailExp" value="${option?.critFailExp !== undefined && option.critFailExp !== 0 ? option.critFailExp : ""}">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <label class="form-label" style="font-size: 0.9rem; margin-bottom: 0.5rem; display: block;">
                            General Outcomes Notes
                        </label>
                        <textarea class="form-textarea" placeholder="Additional notes or context about this option's outcomes..." data-option="outcomes" style="min-height: 80px;">${option?.outcomes || ''}</textarea>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <label class="form-label" style="font-size: 0.9rem;">
                            Follow-up Events (sequential sub-events after this option)
                            <small style="display: block; font-weight: normal; color: rgba(245, 230, 211, 0.6); margin-top: 0.25rem;">
                                Add events that happen in sequence (e.g., e_sen4_a1 â†’ e_sen4_a2)
                            </small>
                        </label>
                        <div class="followup-events-container" data-followup-container>
                            ${followupEventsHtml}
                        </div>
                        <button type="button" class="btn btn-secondary btn-small" onclick="addFollowupEvent(this)" style="margin-top: 0.5rem; width: 100%;">
                            + Add Follow-up Event
                        </button>
                    </div>
                </div>
            `; 
        }

        function createFollowupEventHtml(index, event = null) {
            return `
                ${index > 0 ? '<div class="followup-arrow">â†“</div>' : ''}
                <div class="followup-event-item">
                    <div class="followup-event-header">
                        <span class="followup-event-label">Follow-up ${index + 1}</span>
                        <button type="button" class="followup-event-remove" onclick="removeFollowupEvent(this)">Remove</button>
                    </div>
                    <input type="text" class="form-input" placeholder="Event ID/Name (e.g., 'e_sen4_a2')" data-followup="name" value="${event?.name || ''}" style="margin-bottom: 0.5rem;">
                    <textarea class="form-textarea" placeholder="Event description" data-followup="description" style="min-height: 60px; margin-bottom: 0.5rem;">${event?.description || ''}</textarea>
                    <div class="form-label" style="font-size: 0.85rem; margin-bottom: 0.5rem;">Rewards:</div>
                    <div class="rewards-row">
                        <input type="number" class="form-input" placeholder="Gold" data-followup="gold" value="${event?.gold !== undefined && event.gold !== 0 ? event.gold : ''}">
                        <input type="number" class="form-input" placeholder="Shards" data-followup="shards" value="${event?.shards !== undefined && event.shards !== 0 ? event.shards : ''}">
                        <input type="number" class="form-input" placeholder="EXP" data-followup="exp" value="${event?.exp !== undefined && event.exp !== 0 ? event.exp : ''}">
                    </div>
                </div>
            `;
        }

        function toggleOutcomes(btn) {
            const outcomesSection = btn.nextElementSibling;
            const toggleIcon = btn.querySelector('.toggle-icon');
            
            if (outcomesSection.style.display === 'none') {
                outcomesSection.style.display = 'block';
                toggleIcon.textContent = 'â–¼';
            } else {
                outcomesSection.style.display = 'none';
                toggleIcon.textContent = 'â–¶';
            }
        }

        function addFollowupEvent(btn) {
            const optionItem = btn.closest('.option-item');
            const container = optionItem.querySelector('[data-followup-container]');
            const currentCount = container.querySelectorAll('.followup-event-item').length;
            container.insertAdjacentHTML('beforeend', createFollowupEventHtml(currentCount));
        }

        function removeFollowupEvent(btn) {
            const eventItem = btn.closest('.followup-event-item');
            const arrow = eventItem.previousElementSibling;
            if (arrow && arrow.classList.contains('followup-arrow')) {
                arrow.remove();
            }
            eventItem.remove();
        }

        // ==========================================
        // VARIANT FUNCTIONS
        // ==========================================
        function initializeVariants() {
            currentNodeVariants = [{
                name: 'Combat',
                chance: 100,
                type: 'combat',
                description: '',
                mapLink: null,
                tags: [],
                options: []
            }];
            currentVariantIndex = 0;
            
            // Clear all form fields
            document.getElementById('nodeType').value = 'combat';
            document.getElementById('nodeDescription').value = '';
            
            // Clear tags
            const tagsContainer = document.getElementById('tagsContainer');
            const existingTags = tagsContainer.querySelectorAll('.tag');
            existingTags.forEach(tag => tag.remove());
            
            // Clear options
            resetOptions();
            
            renderVariantTabs();
        }

        function addVariant() {
            // Save current variant before switching
            saveCurrentVariantData();
            
            const newVariant = {
                name: `Variant ${currentNodeVariants.length + 1}`,
                chance: 0,
                type: 'combat',
                description: '',
                mapLink: null,
                tags: [],
                options: []
            };
            
            currentNodeVariants.push(newVariant);
            currentVariantIndex = currentNodeVariants.length - 1;
            
            renderVariantTabs();
            switchToVariant(currentVariantIndex);
        }

        function removeVariant(btn) {
            if (currentNodeVariants.length <= 1) {
                alert('Must have at least one variant');
                return;
            }
            
            if (!confirm('Remove this variant?')) return;
            
            currentNodeVariants.splice(currentVariantIndex, 1);
            currentVariantIndex = Math.max(0, currentVariantIndex - 1);
            
            renderVariantTabs();
            switchToVariant(currentVariantIndex);
        }

        function switchToVariant(index, skipSave = false) {
            // Save current variant data before switching (unless this is the initial load)
            if (!skipSave) {
                saveCurrentVariantData();
            }
            
            currentVariantIndex = index;
            const variant = currentNodeVariants[index];
            
            // Update form with variant data
            document.getElementById('nodeType').value = variant.type;
            document.getElementById('nodeDescription').value = variant.description || '';
            
            // Handle map link
            const mapLinkGroup = document.getElementById('mapLinkGroup');
            if (variant.type === 'transition') {
                mapLinkGroup.style.display = 'block';
                populateMapLinkDropdown();
                document.getElementById('nodeMapLink').value = variant.mapLink || '';
            } else {
                mapLinkGroup.style.display = 'none';
            }
            
            // Update tags
            const tagsContainer = document.getElementById('tagsContainer');
            const existingTags = tagsContainer.querySelectorAll('.tag');
            existingTags.forEach(tag => tag.remove());
            variant.tags.forEach(tag => addTag(tag));
            
            // Update options
            resetOptions();
            if (variant.options && variant.options.length > 0) {
                const optionsContainer = document.getElementById('optionsContainer');
                optionsContainer.innerHTML = '';
                variant.options.forEach((option, idx) => {
                    const optionHtml = createOptionHtml(idx + 1, option);
                    optionsContainer.insertAdjacentHTML('beforeend', optionHtml);
                });
            }
            
            // Update active states
            document.querySelectorAll('.variant-item').forEach((item, idx) => {
                item.classList.toggle('active', idx === index);
            });
            
            renderVariantTabs();
        }

        function saveCurrentVariantData() {
            if (currentVariantIndex >= currentNodeVariants.length) return;
            
            const variant = currentNodeVariants[currentVariantIndex];
            variant.type = document.getElementById('nodeType').value;
            variant.description = document.getElementById('nodeDescription').value;
            variant.mapLink = document.getElementById('nodeMapLink').value || null;
            variant.tags = getTags();
            variant.options = getOptions();
            
            // Update variant name and chance from variant item
            const variantItems = document.querySelectorAll('.variant-item');
            if (variantItems[currentVariantIndex]) {
                const nameInput = variantItems[currentVariantIndex].querySelector('.variant-name-input');
                const chanceInput = variantItems[currentVariantIndex].querySelector('.variant-chance-input');
                if (nameInput) variant.name = nameInput.value;
                if (chanceInput) variant.chance = parseInt(chanceInput.value) || 0;
            }
        }

        function renderVariantTabs() {
            const tabsContainer = document.getElementById('variantTabs');
            const variantsContainer = document.getElementById('variantsContainer');
            
            tabsContainer.innerHTML = '';
            variantsContainer.innerHTML = '';
            
            currentNodeVariants.forEach((variant, index) => {
                // Create tab
                const tab = document.createElement('div');
                tab.className = `variant-tab ${index === currentVariantIndex ? 'active' : ''}`;
                tab.innerHTML = `
                    <span>${variant.name}</span>
                    <span class="variant-tab-chance">(${variant.chance}%)</span>
                `;
                tab.addEventListener('click', () => switchToVariant(index));
                tabsContainer.appendChild(tab);
                
                // Create variant item
                const variantItem = document.createElement('div');
                variantItem.className = `variant-item ${index === currentVariantIndex ? 'active' : ''}`;
                variantItem.dataset.variantIndex = index;
                
                const removeBtn = currentNodeVariants.length > 1 ? '' : 'style="display: none;"';
                
                variantItem.innerHTML = `
                    <div class="variant-header">
                        <input type="text" class="form-input variant-name-input" placeholder="Variant name" value="${variant.name}" style="flex: 1;">
                        <input type="number" class="form-input variant-chance-input" placeholder="%" min="0" max="100" value="${variant.chance}" style="width: 80px; margin-left: 0.5rem;">
                        <span style="margin-left: 0.5rem; color: var(--light);">%</span>
                        <button type="button" class="btn btn-secondary btn-small" onclick="removeVariant(this)" ${removeBtn} style="margin-left: 0.5rem;">Remove</button>
                    </div>
                `;
                
                // Add event listeners for name/chance changes
                const nameInput = variantItem.querySelector('.variant-name-input');
                const chanceInput = variantItem.querySelector('.variant-chance-input');
                
                nameInput.addEventListener('input', () => {
                    variant.name = nameInput.value;
                    updateVariantTabLabels();
                });
                
                chanceInput.addEventListener('input', () => {
                    variant.chance = parseInt(chanceInput.value) || 0;
                    updateVariantTabLabels();
                });
                
                variantsContainer.appendChild(variantItem);
            });
        }

        function updateVariantTabLabels() {
            const tabsContainer = document.getElementById('variantTabs');
            const tabs = tabsContainer.querySelectorAll('.variant-tab');
            
            currentNodeVariants.forEach((variant, index) => {
                if (tabs[index]) {
                    tabs[index].innerHTML = `
                        <span>${variant.name}</span>
                        <span class="variant-tab-chance">(${variant.chance}%)</span>
                    `;
                }
            });
        }

        function addOption() {
            const optionsContainer = document.getElementById('optionsContainer');
            const number = optionsContainer.children.length + 1;
            optionsContainer.insertAdjacentHTML('beforeend', createOptionHtml(number));
        }

        function removeOption(btn) {
            const optionsContainer = document.getElementById('optionsContainer');
            if (optionsContainer.children.length > 1) {
                btn.closest('.option-item').remove();
                updateOptionNumbers();
            }
        }

        function updateOptionNumbers() {
            const options = document.querySelectorAll('.option-item');
            options.forEach((option, index) => {
                option.querySelector('.option-number').textContent = `Option ${index + 1}`;
            });
        }

        function getOptions() {
            const options = [];
            document.querySelectorAll('.option-item').forEach(item => {
                // Get follow-up events for this option
                const followupEvents = [];
                item.querySelectorAll('.followup-event-item').forEach(eventItem => {
                    const event = {
                        name: eventItem.querySelector('[data-followup="name"]').value,
                        description: eventItem.querySelector('[data-followup="description"]').value,
                        gold: parseInt(eventItem.querySelector('[data-followup="gold"]').value) || 0,
                        shards: parseInt(eventItem.querySelector('[data-followup="shards"]').value) || 0,
                        exp: parseInt(eventItem.querySelector('[data-followup="exp"]').value) || 0
                    };
                    if (event.name) followupEvents.push(event);
                });
                
                const option = {
                    label: item.querySelector('[data-option="label"]').value,
                    description: item.querySelector('[data-option="description"]').value,
                    gold: parseInt(item.querySelector('[data-option="gold"]').value) || 0,
                    shards: parseInt(item.querySelector('[data-option="shards"]').value) || 0,
                    exp: parseInt(item.querySelector('[data-option="exp"]').value) || 0,
                    // Success/Fail outcomes
                    onSuccess: item.querySelector('[data-option="onSuccess"]')?.value || '',
                    successGold: parseInt(item.querySelector('[data-option="successGold"]')?.value) || 0,
                    successShards: parseInt(item.querySelector('[data-option="successShards"]')?.value) || 0,
                    successExp: parseInt(item.querySelector('[data-option="successExp"]')?.value) || 0,
                    onCritSuccess: item.querySelector('[data-option="onCritSuccess"]')?.value || '',
                    critSuccessGold: parseInt(item.querySelector('[data-option="critSuccessGold"]')?.value) || 0,
                    critSuccessShards: parseInt(item.querySelector('[data-option="critSuccessShards"]')?.value) || 0,
                    critSuccessExp: parseInt(item.querySelector('[data-option="critSuccessExp"]')?.value) || 0,
                    onFail: item.querySelector('[data-option="onFail"]')?.value || '',
                    failGold: parseInt(item.querySelector('[data-option="failGold"]')?.value) || 0,
                    failShards: parseInt(item.querySelector('[data-option="failShards"]')?.value) || 0,
                    failExp: parseInt(item.querySelector('[data-option="failExp"]')?.value) || 0,
                    onCritFail: item.querySelector('[data-option="onCritFail"]')?.value || '',
                    critFailGold: parseInt(item.querySelector('[data-option="critFailGold"]')?.value) || 0,
                    critFailShards: parseInt(item.querySelector('[data-option="critFailShards"]')?.value) || 0,
                    critFailExp: parseInt(item.querySelector('[data-option="critFailExp"]')?.value) || 0,
                    outcomes: item.querySelector('[data-option="outcomes"]')?.value || '',
                    followupEvents: followupEvents
                };
                if (option.label) options.push(option);
            });
            return options;
        }

        // Map Modal Functions
        let editingMapId = null;

        function openMapModal(mapId = null) {
            if (!isAdmin) {
                alert('Admin access required to edit maps');
                return;
            }

            editingMapId = mapId;
            const modalTitle = mapModal.querySelector('.modal-title');
            const deleteBtn = document.getElementById('deleteMapBtn');
            
            if (mapId) {
                const map = maps.find(m => m.id === mapId);
                if (map) {
                    modalTitle.textContent = 'Edit Map';
                    deleteBtn.style.display = 'block';
                    document.getElementById('mapName').value = map.name;
                    document.getElementById('mapImageUrl').value = map.imageUrl || '';
                    
                    // Update parent select
                    const parentSelect = document.getElementById('parentMap');
                    parentSelect.innerHTML = '<option value="">None (Root Map)</option>';
                    maps.forEach(m => {
                        if (m.id !== mapId) { // Don't allow selecting self as parent
                            const option = document.createElement('option');
                            option.value = m.id;
                            option.textContent = m.name;
                            option.selected = m.id === map.parentId;
                            parentSelect.appendChild(option);
                        }
                    });
                }
            } else {
                modalTitle.textContent = 'Create New Map';
                deleteBtn.style.display = 'none';
                mapForm.reset();
                
                // Update parent map dropdown
                const parentSelect = document.getElementById('parentMap');
                parentSelect.innerHTML = '<option value="">None (Root Map)</option>';
                maps.forEach(map => {
                    const option = document.createElement('option');
                    option.value = map.id;
                    option.textContent = map.name;
                    parentSelect.appendChild(option);
                });
            }
            
            // Show the modal
            mapModal.classList.add('active');
        }

        function editMap(mapId) {
            openMapModal(mapId);
        }

        function deleteMap() {
            if (!editingMapId || !confirm('Are you sure you want to delete this map? All nodes will be lost.')) return;
            
            if (!isAdmin) {
                alert('Admin access required to delete maps');
                return;
            }
            
            // Collect all map IDs to delete (including children)
            const mapsToDelete = [];
            function collectMapAndChildren(mapId) {
                mapsToDelete.push(mapId);
                const children = maps.filter(m => m.parentId === mapId);
                children.forEach(child => collectMapAndChildren(child.id));
            }
            
            collectMapAndChildren(editingMapId);
            
            // Remove from local array
            maps = maps.filter(m => !mapsToDelete.includes(m.id));
            
            // Delete from Supabase
            showLoading();
            Promise.all(mapsToDelete.map(mapId => 
                supabaseClient.from('maps').delete().eq('id', mapId)
            )).then(() => {
                hideLoading();
                
                // Select another map if available
                if (currentMapId === editingMapId) {
                    currentMapId = maps.length > 0 ? maps[0].id : null;
                }
                
                renderMaps();
                if (currentMapId) {
                    renderMapCanvas();
                }
                closeMapModal();
            }).catch(error => {
                hideLoading();
                console.error('Error deleting map:', error);
                alert('Error deleting map: ' + error.message);
            });
        }

        function deleteMapFromSidebar(mapId) {
            if (!isAdmin) {
                alert('Admin access required to delete maps');
                return;
            }

            const map = maps.find(m => m.id === mapId);
            if (!map) return;
            
            const hasChildren = maps.some(m => m.parentId === mapId);
            const warningMsg = hasChildren 
                ? `Are you sure you want to delete "${map.name}"? This will also delete all submaps and their nodes.`
                : `Are you sure you want to delete "${map.name}"? All ${map.nodes.length} node(s) will be lost.`;
            
            if (!confirm(warningMsg)) return;
            
            // Collect all map IDs to delete (including children)
            const mapsToDelete = [];
            function collectMapAndChildren(mapId) {
                mapsToDelete.push(mapId);
                const children = maps.filter(m => m.parentId === mapId);
                children.forEach(child => collectMapAndChildren(child.id));
            }
            
            collectMapAndChildren(mapId);
            
            // Remove from local array
            maps = maps.filter(m => !mapsToDelete.includes(m.id));
            
            // Delete from Supabase
            showLoading();
            Promise.all(mapsToDelete.map(id => 
                supabaseClient.from('maps').delete().eq('id', id)
            )).then(() => {
                hideLoading();
                
                // Select another map if we deleted the current one
                if (currentMapId === mapId) {
                    currentMapId = maps.length > 0 ? maps[0].id : null;
                    if (currentMapId) {
                        selectMap(currentMapId);
                    } else {
                        // No maps left, clear canvas
                        const existingNodes = mapImageContainer.querySelectorAll('.node');
                        existingNodes.forEach(node => node.remove());
                        const img = mapImageContainer.querySelector('.map-image');
                        if (img) img.style.display = 'none';
                    }
                }
                
                renderMaps();
                console.log('Deleted map:', map.name);
            }).catch(error => {
                hideLoading();
                console.error('Error deleting map:', error);
                alert('Error deleting map: ' + error.message);
            });
        }

        function closeMapModal() {
            mapModal.classList.remove('active');
            mapForm.reset();
            editingMapId = null;
        }

        function saveMap(e) {
            e.preventDefault();
            
            const mapName = document.getElementById('mapName').value;
            const parentId = document.getElementById('parentMap').value || null;
            const imageUrl = document.getElementById('mapImageUrl').value;
            const imageFile = document.getElementById('mapImageFile').files[0];
            
            console.log('Saving map:', { mapName, parentId, imageUrl, imageFile, editingMapId });
            
            function finalizeMap(finalImageUrl) {
                if (editingMapId) {
                    // Update existing map
                    const map = maps.find(m => m.id === editingMapId);
                    if (map) {
                        map.name = mapName;
                        map.parentId = parentId;
                        map.imageUrl = finalImageUrl;
                        console.log('Updated map:', map);
                    }
                    saveData();
                    renderMaps();
                    renderMapCanvas();
                } else {
                    // Create new map
                    const newMap = {
                        id: generateId(),
                        name: mapName,
                        parentId: parentId,
                        imageUrl: finalImageUrl,
                        nodes: []
                    };
                    maps.push(newMap);
                    console.log('Created new map:', newMap);
                    saveData();
                    renderMaps();
                    selectMap(newMap.id);
                }
                
                closeMapModal();
            }
            
            // Handle file upload with compression
            if (imageFile) {
                showLoading();
                compressImage(imageFile, 3000, 3000, 0.85)
                    .then(compressedDataUrl => {
                        hideLoading();
                        console.log('Image compressed successfully');
                        finalizeMap(compressedDataUrl);
                    })
                    .catch(error => {
                        hideLoading();
                        console.error('Compression error:', error);
                        alert('Error processing image. Using original...');
                        
                        // Fallback to original method
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            finalizeMap(event.target.result);
                        };
                        reader.readAsDataURL(imageFile);
                    });
            } else {
                finalizeMap(imageUrl);
            }
        }

        // Search Functions
        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            
            if (!query) {
                searchResults.classList.remove('active');
                clearHighlights();
                return;
            }

            const results = [];
            maps.forEach(map => {
                map.nodes.forEach(node => {
                    // Build comprehensive search text from all node fields
                    let searchText = `${node.name} ${node.description || ''} ${node.tags ? node.tags.join(' ') : ''}`;
                    
                    // Search in variants
                    if (node.variants && node.variants.length > 0) {
                        node.variants.forEach(variant => {
                            searchText += ` ${variant.name} ${variant.description || ''}`;
                            searchText += ` ${variant.tags ? variant.tags.join(' ') : ''}`;
                            
                            // Search in variant options
                            if (variant.options && variant.options.length > 0) {
                                variant.options.forEach(option => {
                                    searchText += ` ${option.label || ''} ${option.description || ''}`;
                                    searchText += ` ${option.outcomes || ''}`;
                                    searchText += ` ${option.onSuccess || ''} ${option.onCritSuccess || ''}`;
                                    searchText += ` ${option.onFail || ''} ${option.onCritFail || ''}`;
                                    
                                    // Search in follow-up events
                                    if (option.followupEvents && option.followupEvents.length > 0) {
                                        option.followupEvents.forEach(event => {
                                            searchText += ` ${event.name || ''} ${event.description || ''}`;
                                        });
                                    }
                                });
                            }
                        });
                    } else {
                        // Old format nodes without variants - search in options directly
                        if (node.options && node.options.length > 0) {
                            node.options.forEach(option => {
                                searchText += ` ${option.label || ''} ${option.description || ''}`;
                                searchText += ` ${option.outcomes || ''}`;
                                searchText += ` ${option.onSuccess || ''} ${option.onCritSuccess || ''}`;
                                searchText += ` ${option.onFail || ''} ${option.onCritFail || ''}`;
                                
                                if (option.followupEvents && option.followupEvents.length > 0) {
                                    option.followupEvents.forEach(event => {
                                        searchText += ` ${event.name || ''} ${event.description || ''}`;
                                    });
                                }
                            });
                        }
                    }
                    
                    // Check if query matches anywhere in the comprehensive search text
                    if (searchText.toLowerCase().includes(query)) {
                        results.push({ node, map });
                    }
                });
            });

            displaySearchResults(results);
        }

        function displaySearchResults(results) {
            searchResults.innerHTML = '';
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="no-results">No nodes found</div>';
                searchResults.classList.add('active');
                return;
            }

            results.forEach(({ node, map }) => {
                const item = document.createElement('div');
                item.className = 'search-result-item';
                item.innerHTML = `
                    <div class="result-name">${node.name}</div>
                    <div class="result-meta">${map.name} â€¢ ${node.type}</div>
                `;
                item.addEventListener('click', () => {
                    // Switch to the node's map and wait for it to load
                    selectMap(map.id, () => {
                        // Map is now loaded, center on node and open viewer
                        highlightNode(node.id);
                        viewNode(node.id);
                    });
                    
                    searchResults.classList.remove('active');
                    searchInput.value = '';
                });
                searchResults.appendChild(item);
            });

            searchResults.classList.add('active');
        }

        function highlightNode(nodeId) {
            clearHighlights();
            const map = maps.find(m => m.id === currentMapId);
            const node = map?.nodes.find(n => n.id === nodeId);
            if (!node) {
                console.log('Node not found:', nodeId);
                return;
            }

            console.log('Centering on node:', node.name, 'at position:', node.x, node.y);

            // Calculate where to position the view to center the node
            const rect = mapCanvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Pan to center the node in the viewport
            translateX = centerX - (node.x * scale);
            translateY = centerY - (node.y * scale);
            updateTransform();

            // Add highlight after transform update
            setTimeout(() => {
                const nodeElements = mapImageContainer.querySelectorAll('.node');
                nodeElements.forEach(el => {
                    if (el.dataset.nodeId === nodeId) {
                        el.classList.add('highlighted');
                        console.log('Node highlighted:', nodeId);
                    }
                });
            }, 150);
        }

        function clearHighlights() {
            document.querySelectorAll('.node.highlighted').forEach(node => {
                node.classList.remove('highlighted');
            });
        }

        // Export/Import Functions
        function exportData() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                maps: maps
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `map-forge-export-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('Exported', maps.length, 'maps');
            alert(`Exported ${maps.length} map(s) successfully!`);
        }

        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    
                    // Validate data
                    if (!importedData.maps || !Array.isArray(importedData.maps)) {
                        throw new Error('Invalid data format');
                    }

                    // Ask user what to do with existing data
                    let shouldMerge = false;
                    if (maps.length > 0) {
                        const choice = confirm(
                            `You have ${maps.length} existing map(s).\n\n` +
                            `Click OK to MERGE with imported data (${importedData.maps.length} map(s))\n` +
                            `Click Cancel to REPLACE all existing data`
                        );
                        shouldMerge = choice;
                    }

                    if (shouldMerge) {
                        // Merge: Add imported maps with new IDs to avoid conflicts
                        importedData.maps.forEach(map => {
                            const newMap = {
                                ...map,
                                id: generateId(),
                                parentId: null // Reset parent relationships on merge
                            };
                            maps.push(newMap);
                        });
                    } else {
                        // Replace
                        maps = importedData.maps;
                    }

                    saveData();
                    renderMaps();
                    
                    // Select first map
                    if (maps.length > 0) {
                        selectMap(maps[0].id);
                    }

                    console.log('Imported', importedData.maps.length, 'maps. Total maps:', maps.length);
                    alert(`Successfully imported ${importedData.maps.length} map(s)!`);
                    
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error importing file. Please make sure it\'s a valid Map Forge export file.');
                }
            };
            
            reader.onerror = () => {
                alert('Error reading file');
            };
            
            reader.readAsText(file);
            
            // Reset file input
            e.target.value = '';
        }

        // Utility Functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        // Image compression utility
        async function compressImage(file, maxWidth = 3000, maxHeight = 3000, quality = 0.85) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // Calculate new dimensions
                            let width = img.width;
                            let height = img.height;
                            
                            console.log(`Original dimensions: ${width}x${height}`);
                            
                            if (width > maxWidth || height > maxHeight) {
                                const ratio = Math.min(maxWidth / width, maxHeight / height);
                                width = Math.floor(width * ratio);
                                height = Math.floor(height * ratio);
                                console.log(`Resizing to: ${width}x${height} (${(ratio * 100).toFixed(1)}% of original)`);
                            }
                            
                            // Create canvas and compress
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            
                            // Use better image smoothing for high quality
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            
                            // Draw image
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert to compressed data URL
                            // Use JPEG for photos/complex images, keep PNG for simple graphics
                            const mimeType = file.type === 'image/png' && file.size < 500000 ? 'image/png' : 'image/jpeg';
                            const compressedDataUrl = canvas.toDataURL(mimeType, quality);
                            
                            // Calculate compression stats
                            const originalSize = e.target.result.length;
                            const compressedSize = compressedDataUrl.length;
                            const savings = ((1 - compressedSize / originalSize) * 100).toFixed(1);
                            
                            console.log(`✓ Compression complete!`);
                            console.log(`  Size: ${(originalSize / 1024 / 1024).toFixed(2)}MB → ${(compressedSize / 1024 / 1024).toFixed(2)}MB`);
                            console.log(`  Savings: ${savings}% smaller`);
                            console.log(`  Format: ${mimeType}`);
                            
                            resolve(compressedDataUrl);
                        } catch (error) {
                            console.error('Canvas error:', error);
                            reject(error);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        }

        async function saveData() {
            if (!isAdmin) {
                alert('You must be an admin to make changes');
                return Promise.reject('Not admin');
            }
            return saveToSupabase();
        }

        async function saveToSupabase() {
            try {
                isSaving = true; // Set flag to prevent real-time reload
                showLoading();
                const { error } = await supabaseClient
                    .from('maps')
                    .upsert(maps.map(map => ({
                        id: map.id,
                        name: map.name,
                        parent_id: map.parentId,
                        image_url: map.imageUrl,
                        nodes: map.nodes,
                        display_order: map.displayOrder || 0,
                        updated_at: new Date().toISOString()
                    })));
                
                if (error) throw error;
                console.log('Saved to Supabase');
                hideLoading();
                
                // Wait a bit before clearing flag to ensure real-time event is skipped
                setTimeout(() => {
                    isSaving = false;
                }, 500);
            } catch (error) {
                hideLoading();
                isSaving = false; // Clear flag on error
                console.error('Error saving:', error);
                alert('Error saving changes: ' + error.message);
                throw error;
            }
        }

        async function loadData() {
            return loadFromSupabase();
        }

        async function loadFromSupabase() {
            try {
                const { data, error } = await supabaseClient
                    .from('maps')
                    .select('*')
                    .order('created_at', { ascending: true });
                
                if (error) {
                    console.error('Supabase error:', error);
                    throw error;
                }
                
                if (data && data.length > 0) {
                    maps = data.map(row => ({
                        id: row.id,
                        name: row.name,
                        parentId: row.parent_id,
                        imageUrl: row.image_url,
                        nodes: row.nodes || [],
                        displayOrder: row.display_order !== undefined ? row.display_order : 0
                    }));
                } else {
                    maps = [];
                }
            } catch (error) {
                console.error('Error loading from Supabase:', error);
                // If it's a column error, provide helpful message
                if (error.message && error.message.includes('display_order')) {
                    console.warn('display_order column missing - using default ordering');
                    // Try again without display_order
                    try {
                        const { data, error: retryError } = await supabaseClient
                            .from('maps')
                            .select('id, name, parent_id, image_url, nodes, created_at, updated_at')
                            .order('created_at', { ascending: true });
                        
                        if (!retryError && data) {
                            maps = data.map(row => ({
                                id: row.id,
                                name: row.name,
                                parentId: row.parent_id,
                                imageUrl: row.image_url,
                                nodes: row.nodes || [],
                                displayOrder: 0
                            }));
                            return;
                        }
                    } catch (retryErr) {
                        console.error('Retry failed:', retryErr);
                    }
                }
                maps = [];
                throw error;
            }
        }

        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('active');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }

        // ==========================================
        // AUTHENTICATION
        // ==========================================
        
        // Login button opens modal
        document.getElementById('loginBtn').addEventListener('click', () => {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('loginError').textContent = '';
        });

        // Close login modal
        document.getElementById('closeLoginModalBtn').addEventListener('click', () => {
            document.getElementById('loginModal').classList.remove('active');
        });

        // Login form submission
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const errorEl = document.getElementById('loginError');

            try {
                showLoading();
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email,
                    password
                });
                
                if (error) throw error;
                
                currentUser = data.user;
                isAdmin = true;
                errorEl.textContent = '';
                document.getElementById('loginModal').classList.remove('active');
                
                // Re-initialize as admin
                await initializeApp();
            } catch (error) {
                errorEl.textContent = error.message;
                hideLoading();
            }
        });

        // Logout button
        document.getElementById('logoutBtn').addEventListener('click', async () => {
            if (isAdmin) {
                await supabaseClient.auth.signOut();
            }
            location.reload();
        });

        // Start app as viewer by default
        (async function() {
            try {
                console.log('=== MAP FORGE INITIALIZATION START ===');
                console.log('Supabase URL:', SUPABASE_URL);
                console.log('Supabase Key (first 20 chars):', SUPABASE_ANON_KEY.substring(0, 20) + '...');
                
                isAdmin = false;
                currentUser = null;
                
                console.log('Calling initializeApp...');
                await initializeApp();
                console.log('=== MAP FORGE INITIALIZATION COMPLETE ===');
            } catch (error) {
                hideLoading();
                console.error('=== INITIALIZATION ERROR ===');
                console.error('Error:', error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                
                // Check if it's a Supabase configuration error
                if (SUPABASE_URL === 'YOUR_SUPABASE_URL_HERE' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY_HERE') {
                    alert('âš ï¸ Supabase not configured!\n\nPlease update the SUPABASE_URL and SUPABASE_ANON_KEY in the HTML file.\n\nSee QUICK_START.md for setup instructions.');
                } else {
                    alert('Error loading application:\n\n' + error.message + '\n\nCheck browser console (F12) for details.');
                }
            }
        })();
    </script>
</body>
</html>
